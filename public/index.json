[{"content":"","date":"12 December 2024","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"12 December 2024","permalink":"/posts/","section":"Danh mục post","summary":"","title":"Danh mục post"},{"content":"","date":"12 December 2024","permalink":"/tags/http/","section":"Tags","summary":"","title":"http"},{"content":"","date":"12 December 2024","permalink":"/categories/http/","section":"Categories","summary":"","title":"http"},{"content":"","date":"12 December 2024","permalink":"/tags/javascript/","section":"Tags","summary":"","title":"JavaScript"},{"content":"","date":"12 December 2024","permalink":"/categories/javascript/","section":"Categories","summary":"","title":"JavaScript"},{"content":"Read about your favorite topics on Javascript and java, from Architecture Frameworks and Design Patterns to Engineering Deep Dives into Security, network, and everything else!\n","date":"12 December 2024","permalink":"/posts/javascript/","section":"Danh mục post","summary":"Read about your favorite topics on Javascript and java, from Architecture Frameworks and Design Patterns to Engineering Deep Dives into Security, network, and everything else!","title":"JavaScript Series"},{"content":"","date":"12 December 2024","permalink":"/tags/optimization/","section":"Tags","summary":"","title":"optimization"},{"content":"","date":"12 December 2024","permalink":"/categories/optimization/","section":"Categories","summary":"","title":"optimization"},{"content":" Khi phát triển ứng dụng JavaScript, việc quản lý bộ nhớ đóng vai trò quan trọng trong việc đảm bảo hiệu suất. Tối ưu hóa bộ nhớ giúp cải thiện tốc độ, mang đến trải nghiệm tốt hơn cho người dùng. Vấn đề này, mình nghĩ chắc nhiều bạn cũng đã và đang mắc phải, ngay cả bản thân mình cũng vậy.\nBài viết này, mình sẽ hướng dẫn chi tiết dựa trên kinh nghiệm cá nhân về cách JavaScript quản lý memory, các vấn đề phổ biến và kỹ thuật tối ưu để bạn có thể tạo ra những ứng dụng hiệu quả nhất. Đừng lo lắng, vì nó không quá khó khăn như bạn nghĩ đâu, làm là bị cuốn á.\n1. Hiểu rõ về JavaScript’s Memory Lifecycle # JavaScript quản lý memory thông qua cơ chế Garbage Collection (GC), giúp các developer không cần trực tiếp thao tác cấp phát và giải phóng memory. Tuy nhiên, để hiểu rõ cách tối ưu hóa, bạn cần nắm rõ ba giai đoạn trong memory lifecycle:\nCấp phát (Allocation): JavaScript cấp phát memory khi bạn tạo các variables, object và function. Cách sử dụng (Usage): Memory được sử dụng khi các variables, object hoặc function còn cần trong code. Giải phóng (Garbage Collection): GC sẽ tự động giải phóng memory của các object không còn tham chiếu nào. Ví dụ như: 1 2 3 function allocateMemory() { let data = new Array(1000000).fill(\u0026#34;memory\u0026#34;); } Khi mà allocateMemory chạy, một array lớn sẽ được cấp phát. Khi function hoàn thành, mảng không còn tham chiếu đến data thì GC sẽ giải phóng memory.\nNhưng giả sử mình giữ lại tham chiếu thì sẽ như thế nào?\n1 2 3 4 5 let leakedData; function allocateMemory() { leakedData = new Array(1000000).fill(\u0026#39;memory\u0026#39;); } allocateMemory(); Ở đây, biến toàn cục leakedData vẫn giữ tham chiếu đến mảng, khiến GC không thể giải phóng được memory.\n2. Memory Leaks phổ biến trong JavaScript # Mặc dù JavaScript có cơ chế Garbage Collection, một số lỗi code vẫn khiến memory không được giải phóng, dẫn đến rò rỉ. Dưới đây, là các trường hợp phổ biến và cách phát hiện. 2.1 Biến toàn cục # Biến toàn cục sẽ tồn tại trong suốt vòng đời của ứng dụng và rất hiếm khi được Garbage Collection. Nếu như không cần thiết, việc sử dụng biến toàn cục sẽ gây lãng phí memory.\n1 2 3 4 function myFunc() { globalVar = \u0026#34;I\u0026#39;m a memory leak!\u0026#34;; } myFunc(); Ở đây, globalVar được khai báo không đúng cách (không có let, const hoặc var), vô hình chung sẽ trở thành biến toàn cục.\nCách khắc phục: luôn khai báo biến với let, const, var\n1 2 3 4 function myFunc() { let localVar = \u0026#34;I\u0026#39;m safe!\u0026#34;; } myFunc(); 2.2 Tách biệt DOM Nodes # Khi DOM nodes bị xóa khỏi DOM nhưng vẫn còn được tham chiếu đến, chúng sẽ không bị giải phóng.\n1 2 3 let element = document.getElementById(\u0026#39;myElement\u0026#39;); document.body.removeChild(element); // biến \u0026#39;element\u0026#39; vẫn giữ tham chiếu đến DOM nodes Thường thì để tránh, bạn nên xóa tham chiếu bằng cách gán null.\n1 2 let element = document.getElementById(\u0026#34;myElement\u0026#34;); document.body.removeChild(element); 2.3 Timers và Callbacks Không Được Giải Phóng # Các setInterval, setTimeout giữ lại tham chiếu nếu không được xóa.\nMình để ý thấy nhiều bạn sẽ viết như thế này:\n1 2 3 4 5 6 7 function startTimer() { setInterval(() =\u0026gt; { // Thực hiện một số công việc }, 1000); } startTimer(); // Timer chạy vô thời hạn mà không thấy dừng Để khắc phục điểm này, bạn nên lưu lại ID của timer và xóa khi không còn cần thiết.\n1 2 3 4 5 6 7 8 function startTimer() { let timerId = setInterval(() =\u0026gt; { // Thực hiện một số công việc }, 1000); // clear khi không cần clearInterval(timerId); } startTimer(); 2.4 Closures Không Được Giải Phóng # Closures lưu trữ các biến từ func ngoài. Nếu không cẩn thận, closures có thể giữ lại dữ liệu lớn không cần thiết.\n1 2 3 4 5 6 7 8 function outer() { let bigData = new Array(1000000).fill(\u0026#39;data\u0026#39;); return function inner() { console.log(bigData[0]); }; } let closureFunc = outer(); // \u0026#39;bigData\u0026#39; vẫn tồn tại vì \u0026#39;inner\u0026#39; giữ tham chiếu Khắc phục điểm này bằng cách giảm phạm vi của biến hoặc tránh giữ lại tham chiếu không còn dùng.\n1 2 3 4 5 6 7 8 9 function outer() { let bigData = new Array(1000000).fill(\u0026#39;data\u0026#39;); function inner() { console.log(bigData[0]); } inner(); } outer(); // \u0026#39;bigData\u0026#39; sẽ được giải phóng sau khi \u0026#39;outer\u0026#39; hoàn thành 3. Cách phòng và khắc phục Memory Leaks # Memory leaks xảy ra khi ứng dụng tiếp tục sử dụng bộ nhớ mà không giải phóng nó sau khi không còn dùng. Điều này sẽ dẫn đến việc sử dụng bộ nhớ tăng dần theo thời gian, có thể giảm hiệu suất hoặc treo ứng dụng. Dưới đây là các kỹ thuật phổ biến để ngăn và xử lý memory leaks trong JavaScript.\n3.1 Giảm thiểu biến toàn cục # Biến toàn cục tồn tại trong suốt vòng đời của ứng dụng và không được thu gom bởi Garbage Collector (GC) cho đến khi ứng dụng kết thúc. Việc sử dụng quá nhiều biến toàn cục có thể dẫn đến tiêu tốn bộ nhớ không cần thiết. Bạn hãy cùng theo dõi ví dụ sau:\n1 2 3 4 5 function createLeak() { globalVar = \u0026#39;I am a global variable\u0026#39;; } createLeak(); Trong ví dụ này, globalVar được khai báo mà không sử dụng let, const hoặc var, do đó nó trở thành một biến toàn cục. Vậy vấn đề ở đây là gì?\nBiến toàn cục globalVar sẽ tồn tại cho đến khi ứng dụng kết thúc. Nếu biến này lưu trữ lượng dữ liệu lớn, nó sẽ chiếm nhiều bộ nhớ không dùng. Cách khắc phục vấn đề này khá là đơn giản, bạn hãy nhớ luôn sử dụng let, const hoặc var để giới hạn lại phạm vi của biến. 1 2 3 4 5 6 function scopedFunction() { let localVar = \u0026#34;This is local\u0026#34;; // Sử dụng \u0026#39;localVar\u0026#39; trong phạm vi func } scopedFunction(); // \u0026#39;localVar\u0026#39; không tồn tại bên ngoài func 3.2 Xóa tham chiếu DOM Nodes # Khi bạn thao tác với DOM (Document Object Model), việc tạo và xóa các nút (nodes) là thường xuyên. Nếu bạn không xóa các tham chiếu đến các nút DOM đã bị loại bỏ khỏi cây DOM, bộ nhớ sẽ không được giải phóng.\n1 2 3 4 5 6 let element = document.getElementById(\u0026#39;myElement\u0026#39;); // Xóa phần tử khỏi DOM document.body.removeChild(element); // Nhưng biến \u0026#39;element\u0026#39; vẫn giữ tham chiếu đến nút DOM đã bị xóa Biến element vẫn giữ tham chiếu đến nút DOM đã bị xóa khỏi cây DOM. GC không thể giải phóng bộ nhớ của nút DOM này. Bạn nên gán null cho biến để đảm bảo xóa các tham chiếu đến DOM nodes khi không còn sử dụng. Ví dụ như:\n1 2 3 4 5 // Xóa phần tử khỏi DOM document.body.removeChild(element); // Xóa tham chiếu element = null; Khi bạn tiến hành gán null cho element, bạn sẽ loại bỏ tham chiếu đến nút DOM. GC sẽ xác định rằng nút DOM không còn được tham chiếu ở bất kỳ đâu và giải phóng memory. Lưu ý chút nha, nếu biến element của bạn được tham chiếu ở nhiều nơi khác, bạn cần đảm bảo xóa tất cả các tham chiếu để GC có thể giải phóng memory. 3.3 Quản Lý Event Listeners và Timers # 3.3.1 Timers # Các bộ đếm thời gian (setInterval, setTimeout) và event listeners nếu không được xóa khi không cần thiết sẽ giữ lại các tham chiếu đến hàm callback và các biến liên quan.\nĐối với setInterval, thường bạn sẽ sử dụng thế này đúng không?\n1 2 3 4 5 6 7 8 function startAutoRefresh() { setInterval(() =\u0026gt; { // Thực hiện một số công việc }, 1000); } startAutoRefresh(); // Timer sẽ chạy vô thời hạn nếu không được dừng Nếu bạn đang sử dụng như thế này, sẽ xảy ra vấn đề:\nsetInterval tiếp tục chạy mãi mãi, ngay cả khi không còn sử dụng. Điều này gây lãng phí tài nguyên và bộ nhớ. Vậy nên, bạn hãy kiểm tra và sử dụng clearInterval để dừng bộ đếm thời gian khi không còn cần thiết. Ví dụ như sau: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 let intervalId; function startAutoRefresh() { intervalId = setInterval(() =\u0026gt; { // TODO: ... }, 1000); } function stopAutoRefresh() { clearInterval(intervalId); } startAutoRefresh(); // Khi không còn cần thiết stopAutoRefresh(); Giải thích một chút về ví dụ trên:\nMình lưu lại ID của bộ đếm để có thể dừng nó sau này, khi mà không còn sử dụng nữa Gọi clearInterval(intervalId) để dừng bộ đếm thời gian và giải phóng memory. 3.3.2 Event Listeners # Bạn hãy theo dõi ví dụ này:\n1 2 3 4 5 6 7 8 9 function attachEvent() { let element = document.getElementById(\u0026#39;myButton\u0026#39;); element.addEventListener(\u0026#39;click\u0026#39;, function handleClick() { // Xử lý sự kiện }); } attachEvent(); // Listener sẽ tồn tại ngay cả khi \u0026#39;element\u0026#39; bị xóa khỏi DOM Event listener giữ tham chiếu đến element và hàm handleClick. Nếu không gỡ bỏ listener, memory sẽ không được giải phóng. Chú ý sử dụng removeEventListener để gỡ bỏ listener khi không còn sử dụng 1 2 3 4 5 6 7 8 9 10 11 12 13 14 function attachEvent() { let element = document.getElementById(\u0026#39;myButton\u0026#39;); function handleClick() { // Xử lý sự kiện } element.addEventListener(\u0026#39;click\u0026#39;, handleClick); // Khi không còn cần thiết element.removeEventListener(\u0026#39;click\u0026#39;, handleClick); } attachEvent(); Luôn lưu trữ hàm callback trong một biến hoặc hàm đặt tên để có thể gỡ bỏ sau này. Gọi removeEventListener với cùng loại sự kiện và hàm callback để gỡ bỏ listener. Một lưu ý nhỏ khi bạn làm việc với ứng dụng Single Page (SPA): Ở trong SPA, các component có thể được thêm và xóa động, việc quản lý event listeners và timers sẽ càng quan trọng để ngăn ngừa memory leaks. Ví dụ trong React Component:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import React, { useEffect } from \u0026#39;react\u0026#39;; function MyComponent() { useEffect(() =\u0026gt; { const intervalId = setInterval(() =\u0026gt; { // Thực hiện một số công việc }, 1000); return () =\u0026gt; { // Hàm cleanup clearInterval(intervalId); }; }, []); return \u0026lt;div\u0026gt;My Component\u0026lt;/div\u0026gt;; } export default MyComponent; Sử dụng hàm cleanup trong useEffect để dọn dẹp timers khi component bị unmount. Giúp ngăn ngừa memory leaks khi component không còn hiển thị. 4. Các kỹ thuật tối ưu (Optimization) memory # Ngoài việc tránh rò rỉ memory, tối ưu hóa bộ nhớ sẽ giúp cải thiện hiệu suất ứng dụng. Dưới đây là một số kỹ thuật bạn nên biết đến\n4.1 Sử dụng Weak References (WeakMap, WeakSet) # Weak References là các tham chiếu yếu đến đối tượng, cho phép Garbage Collector - GC giải phóng bộ nhớ khi không còn tham chiếu mạnh nào đến đối tượng đó.\nTrong JavaScript, WeakMap và WeakSet là hai cấu trúc dữ liệu hỗ trợ Weak References. WeakMap lưu trữ cặp key-value, trong đó key là một đối tượng và value có thể là bất kỳ loại dữ liệu nào. WeakSet lưu trữ các đối tượng duy nhất. Ví dụ khi bạn sử dụng Map 1 2 3 4 5 6 7 8 let map = new Map(); let obj = { name: \u0026#39;Object 1\u0026#39; }; map.set(obj, \u0026#39;Some metadata\u0026#39;); // Xóa tham chiếu gốc obj = null; // Đối tượng \u0026#39;obj\u0026#39; vẫn tồn tại trong \u0026#39;map\u0026#39;, ngăn GC giải phóng bộ nhớ Mặc dù mình đã gán obj = null, đối tượng vẫn được giữ lại trong map. Bạn nên sử dụng WeakMap để khắc phục vấn đề này:\n1 2 3 4 5 6 let weakMap = new WeakMap(); let obj = { name: \u0026#39;Object 1\u0026#39; }; weakMap.set(obj, \u0026#39;Some metadata\u0026#39;); // Xóa tham chiếu gốc obj = null; Khi obj không còn được tham chiếu ở nơi nào khác ngoài weakMap, GC sẽ tự động giải phóng bộ nhớ của obj.\nNhưng hãy cẩn thận, cân nhắc khi sử dụng WeakMap:\nWeakMap chỉ chấp nhận các keys là đối tượng, không phải là giá trị nguyên thủy như số hay chuỗi. Không thể lặp qua WeakMap hoặc WeakSet bằng cách sử dụng vòng lặp for\u0026hellip;of hoặc các phương thức như forEach, vì các keys có thể biến mất bất cứ lúc nào do GC. Theo mình, thì chỉ nên sử dụng khi: cần lưu trữ dữ liệu phụ liên quan đến đối tượng mà không muốn ngăn cản việc GC giải phóng đối tượng đó. Ví dụ: lưu trữ trạng thái, metadata hoặc các thông tin tạm thời khác. 4.2 Lazy Loading # Lazy Loading là kỹ thuật trì hoãn việc khởi tạo hoặc tải dữ liệu cho đến khi thực sự cần thiết. Mục đích là giảm thiểu việc sử dụng tài nguyên hệ thống (bộ nhớ, băng thông) và cải thiện hiệu suất.\nCác lợi ích khi sử dụng Lazy Loading:\nTiết kiệm bộ nhớ: chỉ sử dụng bộ nhớ khi cần thiết. Tăng tốc độ khởi động ứng dụng: tránh tải các tài nguyên không cần thiết ngay lập tức. Cải thiện trải nghiệm người dùng: ứng dụng phản hồi nhanh hơn. 1 2 3 4 5 6 7 8 9 10 11 // Tải dữ liệu lớn ngay khi ứng dụng khởi động let heavyData = loadHeavyData(); function loadHeavyData() { // Giả sử đây là hàm tải dữ liệu lớn return new Array(1000000).fill(\u0026#39;data\u0026#39;); } function processData() { // Sử dụng \u0026#39;heavyData\u0026#39; để xử lý } heavyData được tải ngay cả khi processData chưa được gọi. Lãng phí bộ nhớ nếu heavyData không được sử dụng. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 let heavyData = null; function getHeavyData() { if (!heavyData) { heavyData = loadHeavyData(); } return heavyData; } function loadHeavyData() { // Giả sử đây là hàm tải dữ liệu lớn return new Array(1000000).fill(\u0026#39;data\u0026#39;); } function processData() { let data = getHeavyData(); // Sử dụng \u0026#39;data\u0026#39; để xử lý } heavyData chỉ được khởi tạo khi getHeavyData được gọi lần đầu tiên.\nNếu như processData không bao giờ được gọi, heavyData sẽ không bao giờ được load. Trong thực tế bạn cũng dễ dàng thấy được:\nTải hình ảnh hoặc video khi người dùng cuộn đến (ví dụ: trên các trang web dài).\nTải module hoặc component khi cần thiết trong các ứng dụng SPA (Single Page Application).\nKết nối cơ sở dữ liệu hoặc thư viện bên ngoài chỉ khi cần sử dụng. Đừng quá lạm dụng lazy loading, bạn cần đảm bảo việc trì hoãn sẽ không ảnh hưởng đến trải nghiệm người dùng (ví dụ: không gây ra độ trễ đáng kể khi người dùng thực sự cần dữ liệu).\n4.3 Cấu trúc Dữ liệu Map, Set # Map và Set là các cấu trúc dữ liệu được cung cấp trong ES6, cung cấp hiệu suất và tính năng vượt trội so với Object và Array trong một số trường hợp.\nMap: lưu trữ cặp key-value, keys có thể là bất kỳ loại dữ liệu nào (bao gồm cả object, function).\nSet: lưu trữ các giá trị duy nhất, không trùng lặp. Lợi ích:\nHiệu suất cao hơn: các thao tác thêm, xóa, tìm kiếm nhanh hơn với dữ liệu lớn.\nLinh hoạt: keys trong Map có thể là bất kỳ giá trị nào, không chỉ là string.\nTránh trùng lặp: Set đảm bảo mỗi giá trị chỉ xuất hiện duy nhất một lần.\n1 2 3 4 5 6 7 8 9 let data = {}; for (let i = 0; i \u0026lt; 1000000; i++) { data[\u0026#39;key\u0026#39; + i] = \u0026#39;value\u0026#39; + i; } // Kiểm tra sự tồn tại của một key if (data.hasOwnProperty(\u0026#39;key500000\u0026#39;)) { // Thực hiện công việc } Các thao tác với Object có thể chậm khi số lượng keys lớn. Keys trong Object chỉ có thể là chuỗi hoặc symbol. Các phương thức kế thừa từ Object.prototype có thể gây ra xung đột. Bạn có thể cải thiện đoạn code trên với Map 1 2 3 4 5 6 7 8 9 let data = new Map(); for (let i = 0; i \u0026lt; 1000000; i++) { data.set(\u0026#39;key\u0026#39; + i, \u0026#39;value\u0026#39; + i); } // Kiểm tra sự tồn tại của một key if (data.has(\u0026#39;key500000\u0026#39;)) { // Thực hiện công việc } Hay bạn có thể sử dụng Set để loại bỏ sự trùng lặp trong dữ liệu\n1 2 3 4 5 let arrayWithDuplicates = [1, 2, 3, 2, 1, 4, 5]; let uniqueArray = Array.from(new Set(arrayWithDuplicates)); console.log(uniqueArray); // Kết quả: [1, 2, 3, 4, 5] 4.4 Pooling # Object Pooling là kỹ thuật tái sử dụng các đối tượng đã tạo thay vì tạo mới mỗi lần cần. Phù hợp khi việc khởi tạo đối tượng tốn kém về tài nguyên (CPU, bộ nhớ) và bạn cần tạo nhiều đối tượng tương tự trong suốt quá trình chạy ứng dụng.\nTránh việc tạo và hủy đối tượng liên tục. Giảm thiểu việc cấp phát và giải phóng bộ nhớ. Ứng dụng chạy mượt hơn, đặc biệt trong các trò chơi hoặc các ứng dụng đồ họa. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function createParticle() { return { x: 0, y: 0, velocityX: Math.random(), velocityY: Math.random(), // Các thuộc tính khác }; } function simulate() { let particles = []; for (let i = 0; i \u0026lt; 1000; i++) { particles.push(createParticle()); } // Thực hiện mô phỏng với particles // Sau khi xong, particles sẽ được GC thu gom } Bạn có thể nhận thấy:\nMỗi lần simulate được gọi, 1000 đối tượng mới sẽ được tạo. Gây áp lực lên GC khi phải thu gom nhiều đối tượng ngắn hạn. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 const particlePool = []; function getParticle() { if (particlePool.length \u0026gt; 0) { return particlePool.pop(); } else { return { x: 0, y: 0, velocityX: 0, velocityY: 0, // Các thuộc tính khác }; } } function releaseParticle(particle) { // Đặt lại trạng thái của particle nếu cần particle.x = 0; particle.y = 0; particle.velocityX = 0; particle.velocityY = 0; particlePool.push(particle); } function simulate() { let particles = []; for (let i = 0; i \u0026lt; 1000; i++) { let particle = getParticle(); particle.velocityX = Math.random(); particle.velocityY = Math.random(); particles.push(particle); } // Thực hiện mô phỏng với particles // Sau khi xong, đưa các particles trở lại pool for (let particle of particles) { releaseParticle(particle); } } getParticle:\nKiểm tra xem có đối tượng nào trong pool không.\nNếu có, sẽ lấy ra và sử dụng. Nếu không, tạo mới một đối tượng. releaseParticle:\nĐặt lại trạng thái của đối tượng để chuẩn bị cho lần sử dụng tiếp theo.\nĐưa đối tượng trở lại pool. simulate:\nSử dụng các đối tượng từ pool thay vì tạo mới.\nSau khi sử dụng xong, trả lại đối tượng vào pool. Lưu ý:\nCần cẩn thận khi tái sử dụng đối tượng để tránh giữ lại dữ liệu cũ không mong muốn.\nĐảm bảo reset hoặc khởi tạo lại các thuộc tính của đối tượng trước khi sử dụng lại.\nObject Pooling có thể không phù hợp với mọi trường hợp. Cân nhắc trước giữa lợi ích và sự phức tạp trước khi triển khai.\n5. Kết luận # Quản lý bộ nhớ hiệu quả không phải là một nhiệm vụ dễ dàng, nhưng lại có sức hút mạnh mẽ, bạn sẽ thấy nó trở thành một phần tự nhiên trong quy trình phát triển của mình. Đừng ngần ngại thử nghiệm và áp dụng những gì bạn đã học vào dự án thực tế. Những cải tiến nhỏ trong cách bạn quản lý bộ nhớ hôm nay có thể mang lại những lợi ích lớn về hiệu suất và trải nghiệm của người dùng.\n","date":"12 December 2024","permalink":"/posts/javascript/javascriptblog/blog4/","section":"Danh mục post","summary":"Khi phát triển ứng dụng JavaScript, việc quản lý bộ nhớ đóng vai trò quan trọng trong việc đảm bảo hiệu suất.","title":"Quản lý và Tối ưu hóa Memory trong JavaScript"},{"content":"","date":"12 December 2024","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"Chào mừng bạn đến với blog của tôi, nơi bạn có thể tìm thấy các thông tin bài viết về java và javascript, các bài viết về các công nghệ mới nhất, các bài viết về các vấn đề liên quan. Mong blog này sẽ giúp bạn có thêm kiến thức và kinh nghiệm trong việc học lập trình. Chúc bạn thành công!\n","date":"12 December 2024","permalink":"/","section":"Welcome to Totgo Blog!","summary":"Chào mừng bạn đến với blog của tôi, nơi bạn có thể tìm thấy các thông tin bài viết về java và javascript, các bài viết về các công nghệ mới nhất, các bài viết về các vấn đề liên quan.","title":"Welcome to Totgo Blog!"},{"content":"Ngày nay, sự tương tác giữa các ứng dụng web dựa trên HTTP. Ví dụ, giả sử bạn có một ứng dụng cửa hàng trực tuyến và bạn muốn tạo một sản phẩm mới. Bạn phải điền tất cả thông tin cần thiết và có thể nhấp vào nút \u0026ldquo;Tạo\u0026rdquo;.\nHành động này sẽ gửi một HTTP request đến backend cùng với tất cả dữ liệu cần thiết và ứng dụng backend sẽ sử dụng dữ liệu đó để thực hiện các thay đổi đối với cơ sở dữ liệu. Sau khi hành động hoàn tất, cho dù thành công hay không, một HTTP response sẽ được gửi lại cho frontend, nơi nó sẽ hoạt động tương ứng dựa trên trạng thái của phản hồi đó.\nKhi các request và response này được truyền qua và lại, chúng cần tuân theo một định dạng nhất định để cả hai đầu có thể hiểu nhau. HTTP được tạo ra cho mục đích này. Nó là một giao thức mạng tiêu chuẩn cho phép các ứng dụng web hiểu và giao tiếp với nhau.\nCác phương thức HTTP Request phổ biến # Có một số phương thức bạn có thể sử dụng để gửi HTTP request và mỗi phương thức phục vụ một mục đích khác nhau, như được hiển thị bên dưới:\n1. Phương thức GET # Phương thức GET được sử dụng để yêu cầu dữ liệu và tài nguyên từ máy chủ. Khi bạn gửi yêu cầu GET, các tham số truy vấn được nhúng trong URL theo các cặp name/value như thế này:\nhttp://example.com/index.html?name1=value1\u0026amp;name2=value2 Lưu ý rằng dấu hỏi chấm (?) biểu thị phần đầu của danh sách các tham số. Mỗi tham số tạo thành một cặp key/value (name=value) và dấu và (\u0026amp;) được sử dụng để phân chia hai tham số khác nhau.\n2. Phương thức POST # Phương thức POST được sử dụng để gửi dữ liệu đến máy chủ, cho dù là thêm một tài nguyên mới hay cập nhật một tài nguyên hiện có. Các tham số được lưu trữ trong phần thân của HTTP request.\nPOST /index.html HTTP/1.1 Host: example.com name1=value1\u0026amp;name2=value2 3. Phương thức DELETE # Phương thức này xóa một tài nguyên khỏi máy chủ.\n4. Phương thức HEAD # Phương thức HEAD hoạt động giống như GET ngoại trừ việc HTTP response được gửi từ máy chủ sẽ chỉ chứa phần đầu nhưng không phải phần thân. Điều này có nghĩa là nếu máy chủ \u0026ldquo;OK\u0026rdquo; với yêu cầu, nó sẽ cung cấp cho bạn phản hồi 200 OK nhưng không phải là tài nguyên bạn đã yêu cầu. Bạn chỉ có thể truy xuất tài nguyên bằng phương thức GET.\nĐiều này rất hữu ích khi bạn đang kiểm tra xem máy chủ có hoạt động hay không. Đôi khi, tài nguyên có thể mất nhiều thời gian để được truyền tải và cho mục đích thử nghiệm, bạn chỉ cần phản hồi 200 OK để biết rằng mọi thứ hoạt động bình thường.\n5. Phương thức PUT # Phương thức PUT được sử dụng để cập nhật các tài nguyên hiện có và nó tương tự như phương thức POST với một điểm khác biệt nhỏ.\nKhi bạn PUT một tài nguyên đã tồn tại, tài nguyên cũ sẽ bị ghi đè. Và việc thực hiện nhiều yêu cầu PUT giống hệt nhau sẽ có tác dụng như thực hiện một lần.\nKhi bạn POST các tài nguyên giống hệt nhau, tài nguyên đó sẽ bị nhân đôi mỗi khi yêu cầu được thực hiện.\nFetch API Trong JavaScript # Trong một thời gian dài, cộng đồng JavaScript thiếu một cách tiêu chuẩn để gửi HTTP request. Một số người đã sử dụng XMLHttpRequest, hay còn gọi là AJAX, trong khi những người khác lại thích các thư viện bên ngoài như Axios hoặc jQuery.\nFetch API được giới thiệu vào năm 2015 như một cách hiện đại, đơn giản hóa và tiêu chuẩn để tạo HTTP request bằng JavaScript. Nó được hỗ trợ nguyên bản, vì vậy không cần phải cài đặt bất kỳ thư viện của bên thứ ba nào.\nGửi GET Request Với JavaScript # Fetch API dựa trên cơ chế promise, điều này có nghĩa là nó cung cấp một cú pháp rõ ràng và ngắn gọn để viết các hoạt động không đồng bộ. Ví dụ, đây là cách bạn có thể gửi yêu cầu GET bằng Fetch API.\n1 2 3 4 5 6 7 8 9 10 11 12 fetch(\u0026#34;https://jsonplaceholder.typicode.com/users\u0026#34;) .then((response) =\u0026gt; { // If the response is not 2xx, throw an error if (!response.ok) { throw new Error(\u0026#34;Network response was not ok\u0026#34;); } // If the response is 200 OK, return the response in JSON format. return response.json(); }) .then((data) =\u0026gt; console.log(data)) // You can continue to do something to the response. .catch((error) =\u0026gt; console.error(\u0026#34;Fetch error:\u0026#34;, error)); // In case of an error, it will be captured and logged Bạn cũng có thể bao gồm các tùy chọn tùy chỉnh với yêu cầu, chẳng hạn như tiêu đề tùy chỉnh, mã thông báo ủy quyền, v.v.\n1 2 3 4 5 6 7 8 fetch(\u0026#34;https://jsonplaceholder.typicode.com/users\u0026#34;, { headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34;, \u0026#34;Authorization\u0026#34;: \u0026#34;your-token-here\u0026#34;, }, credentials: \u0026#34;same-origin\u0026#34;, }) .then(. . .); Gửi POST Request với JavaScript # Khi gửi yêu cầu POST, mọi thứ trở nên phức tạp hơn một chút vì bạn cần gửi dữ liệu đến máy chủ với phần thân yêu cầu. Điều này có thể trở nên phức tạp tùy thuộc vào loại dữ liệu bạn đang gửi và trường hợp sử dụng cụ thể của bạn.\nVí dụ, đoạn mã sau gửi dữ liệu JSON đến backend:\n1 2 3 4 5 6 7 8 9 10 fetch(\u0026#34;https://jsonplaceholder.typicode.com/users\u0026#34;, { method: \u0026#34;POST\u0026#34;, headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34;, }, body: JSON.stringify({ name: \u0026#34;John Doe\u0026#34;, email: \u0026#34;johndoe@example.com\u0026#34;, }), }); Có một vài điều bạn phải chú ý ở đây. Trước hết, bạn phải chỉ định rõ ràng phương thức yêu cầu. Nếu bạn bỏ qua điều này, phương thức GET mặc định sẽ được sử dụng.\nNgoài ra, phần thân yêu cầu chỉ chấp nhận dữ liệu chuỗi, vì vậy bạn phải sử dụng phương thức stringify() để chuyển đổi JSON thành chuỗi trước khi gán nó cho phần thân yêu cầu.\nĐây cũng là lý do tại sao điều quan trọng là phải bao gồm tiêu đề Content-Type, cho phép bất kỳ ai ở phía nhận biết cách phân tích cú pháp phần thân yêu cầu.\nTuy nhiên, mọi thứ thường phức tạp hơn trong thực tế. Ví dụ, khi làm việc với các biểu mẫu web, thay vì JSON, bạn có thể đang sử dụng mã hóa biểu mẫu x-www-form-urlencoded, trong trường hợp này, yêu cầu có thể được gửi như thế này.\nVí dụ sau giả định rằng bạn hiểu trình xử lý sự kiện là gì.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 document.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, function () { const form = document.querySelector(\u0026#34;form\u0026#34;); const usernameInput = document.getElementById(\u0026#34;username\u0026#34;); const emailInput = document.getElementById(\u0026#34;email\u0026#34;); const formData = new URLSearchParams(); usernameInput.addEventListener(\u0026#34;input\u0026#34;, function () { formData.set(\u0026#34;username\u0026#34;, usernameInput.value); }); emailInput.addEventListener(\u0026#34;input\u0026#34;, function () { formData.set(\u0026#34;email\u0026#34;, emailInput.value); }); form.addEventListener(\u0026#34;submit\u0026#34;, async function (event) { event.preventDefault(); // Prevent the default form submission action await fetch(\u0026#34;https://jsonplaceholder.typicode.com/users\u0026#34;, { method: \u0026#34;POST\u0026#34;, body: formData.toString(), headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;application/x-www-form-urlencoded\u0026#34;, }, }); }); }); Nếu bạn cần tải tệp lên backend, bạn sẽ cần mã hóa biểu mẫu multipart/form-data.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 document.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, function () { const form = document.getElementById(\u0026#34;myForm\u0026#34;); const usernameInput = document.getElementById(\u0026#34;username\u0026#34;); const emailInput = document.getElementById(\u0026#34;email\u0026#34;); const pictureInput = document.getElementById(\u0026#34;picture\u0026#34;); const formData = new FormData(); usernameInput.addEventListener(\u0026#34;input\u0026#34;, function () { formData.set(\u0026#34;username\u0026#34;, usernameInput.value); }); emailInput.addEventListener(\u0026#34;input\u0026#34;, function () { formData.set(\u0026#34;email\u0026#34;, emailInput.value); }); pictureInput.addEventListener(\u0026#34;change\u0026#34;, function () { formData.set(\u0026#34;picture\u0026#34;, pictureInput.files[0]); }); form.addEventListener(\u0026#34;submit\u0026#34;, async function (event) { event.preventDefault(); // Prevent the default form submission await fetch(\u0026#34;https://jsonplaceholder.typicode.com/users\u0026#34;, { method: \u0026#34;POST\u0026#34;, body: formData, }); }); }); Lưu ý rằng khi sử dụng FormData() để tạo phần thân yêu cầu, Content-Type sẽ bị khóa thành multipart/form-data. Trong trường hợp này, không cần thiết phải đặt tiêu đề Content-Type tùy chỉnh.\nGửi PUT và DELETE Request với JavaScript # Yêu cầu PUT hoạt động tương tự như POST, nhưng bạn phải nhớ đặt method thành PUT.\n1 2 3 4 5 6 7 8 9 10 11 fetch(\u0026#34;https://jsonplaceholder.typicode.com/users\u0026#34;, { method: \u0026#34;PUT\u0026#34;, headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34;, }, body: JSON.stringify({ id: \u0026#34;123\u0026#34; name: \u0026#34;John Doe\u0026#34;, email: \u0026#34;johndoe@example.com\u0026#34;, }), }); Thực tế, bạn sẽ phải cung cấp id hoặc bất kỳ khóa nào khác cho phép bạn xác định vị trí bản ghi cần cập nhật trong backend.\nYêu cầu DELETE hoạt động tương tự như PUT, nhưng hãy nhớ đặt method thành DELETE.\n1 2 3 fetch(\u0026#34;https://jsonplaceholder.typicode.com/users/123\u0026#34;, { method: \u0026#34;DELETE\u0026#34;, }); Và tương tự, hãy nhớ cung cấp một id để ứng dụng backend biết bản ghi nào cần xóa.\nCách gửi yêu cầu bằng XMLHttpRequest (AJAX) # Ngoài fetch() ra, chúng ta cũng có thể thực hiện HTTP Request bằng cách sử dụng XMLHttpRequest. Ví dụ sau đây minh họa cách yêu cầu thực hiện đến điểm cuối https://jsonplaceholder.typicode.com\n1 2 3 4 5 6 7 8 9 10 11 12 13 var xhr = new XMLHttpRequest(); xhr.open(\u0026#34;GET\u0026#34;, \u0026#34;https://jsonplaceholder.typicode.com/users\u0026#34;, true); xhr.onload = function () { if (xhr.status \u0026gt;= 200 \u0026amp;\u0026amp; xhr.status \u0026lt; 300) { console.log(JSON.parse(xhr.responseText)); } else { console.error(\u0026#34;Error:\u0026#34;, xhr.statusText); } }; xhr.onerror = function () { console.error(\u0026#34;Request failed\u0026#34;); }; xhr.send(); Cú pháp phức tạp hơn một chút vì XMLHttpRequest dựa vào các hàm gọi lại để làm việc với các hoạt động không đồng bộ, nghĩa là dễ dẫn đến tình trạng được gọi là callback hell, nơi bạn có nhiều lớp hàm gọi lại, khiến cơ sở mã của bạn khó đọc và bảo trì.\nTuy nhiên, XMLHttpRequest có một số ưu điểm. Do thực tế là XMLHttpRequest cũ hơn nhiều so với fetch(), nên nó được hỗ trợ rộng rãi hơn. Bạn nên cân nhắc sử dụng XMLHttpRequest khi ứng dụng web của bạn cần tương thích với các trình duyệt cũ hơn.\nCách gửi Request sử dụng thư viện bên ngoài # Ngoài các phương thức tích hợp, bạn cũng có thể gửi HTTP Request bằng các thư viện của bên thứ ba. Ví dụ, đây là cách bạn có thể gửi yêu cầu GET bằng jQuery:\n1 2 3 4 5 $.get(\u0026#34;https://api.example.com/data\u0026#34;, function (data) { console.log(data); }).fail(function (error) { console.error(\u0026#34;Error:\u0026#34;, error); }); jQuery là một trong những thư viện JavaScript phổ biến nhất. Nó nhằm mục đích sửa phần JavaScript khó sử dụng và đã khá thành công.\nTrong những năm gần đây, jQuery đã mất đi một số sự phổ biến vì JavaScript đã liên tục được cải thiện qua nhiều năm và các vấn đề từng làm phiền mọi người đến nay đã được khắc phục. Nó không còn là lựa chọn hàng đầu để tạo ứng dụng JavaScript, đặc biệt là đối với các lập trình viên mới.\nNgoài ra, bạn có thể sử dụng Axios, một trình khách HTTP dựa trên promise-based HTTP giống như fetch(), và đã được mọi người ưa chuộng trong một thời gian rất dài trước khi fetch()ra mắt.\n1 2 3 4 axios .get(\u0026#34;https://api.example.com/data\u0026#34;) .then((response) =\u0026gt; console.log(response.data)) .catch((error) =\u0026gt; console.error(\u0026#34;Axios error:\u0026#34;, error)); Axios và fetch() có cú pháp rất giống nhau vì cả hai đều dựa trên promise-based. Sự khác biệt chính giữa chúng là fetch() được tích hợp sẵn, trong khi Axios yêu cầu bạn phải cài đặt một thư viện bên ngoài. Tuy nhiên, Axios có nhiều tính năng hơn nhiều vì nó đi kèm với các trình chặn yêu cầu/phản hồi, xử lý JSON tự động và thời gian chờ tích hợp sẵn.\nHy vọng qua bài viết này, bạn đã biết cách để gửi HTTP Request trong JavaScript bằng nhiều cách khác nhau. Cảm ơn các bạn đã theo dõi.\n","date":"12 November 2024","permalink":"/posts/javascript/javascriptblog/blog2/","section":"Danh mục post","summary":"Ngày nay, sự tương tác giữa các ứng dụng web dựa trên HTTP.","title":"Gửi HTTP Request trong JavaScript: Hướng dẫn toàn diện cho người mới bắt đầu"},{"content":"","date":"12 November 2024","permalink":"/series/javascript/","section":"Series","summary":"","title":"JavaScript"},{"content":" JavaScript series # Chương đầu tiên này sẽ trình bày về những khái niệm căn bản nhất trong JavaScript. Bài viết này là một phần của series JavaScript dành cho người mới tiếp cận javascript, giúp các bạn đã có kinh nghiệm code trong các ngôn ngữ khác nhanh chóng làm quen với JS. Nếu được rất mong nhận được sự ủng hộ và đóng góp ý kiến của mọi người để hoàn thiện series.\nA. JS introduction # 1. Introduction # JavaScript (JS) là một ngôn ngữ lập trình client side, được dùng trong trang web bên cạnh HTML và CSS. HTML dùng tạo bộ xương cho trang web, CSS trang trí và tạo layout cho trang web lung linh hơn, thì JS lập trình để có những hành vi, tương tác với người dùng.\nHiện nay, JS không chỉ có thể viết client side mà còn mở rộng ra nhiều lĩnh vực khác, có thể kể tới như viết app với Electron hoặc web service với Node.js. Các thư viện, framework cho JS phát triển rất mạnh, như jquery, React, Angular, Vue,\u0026hellip;\nLưu ý, JS không phải Java.\nTrong series này chỉ nói tới JS ở khía cạnh cơ bản nhất, là tạo tương tác cho trang web. JS được chạy trong trình duyệt và hầu hết trình duyệt hiện nay đều support tốt JS.\nJS là ngôn ngữ có phân biệt hoa thường.\n2. Đặt code ở đâu? # Script tag trong HTML\nCode JS có thể được đặt trong một tag script, và HTML document có thể chứa nhiều script như vậy.\n1 2 3 4 \u0026lt;script\u0026gt; // Đây là đoạn mã JavaScript console.log(\u0026#34;Hello, Hugo garnacho!\u0026#34;); \u0026lt;/script\u0026gt; Các đoạn code JS trong cùng document có thể được gọi, sử dụng lẫn nhau. External JS\nCode JS cũng có thể chứa trong một file riêng, và được liên kết vào HTML cũng bằng thẻ script.\n1 \u0026lt;script src=\u0026#34;script.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; HTML event\nCác thuộc tính event của các HTML tag cũng có thể chứa script. Và code được gọi khi event xảy ra (fire - được bắn ra).\n1 \u0026lt;button type=\u0026#34;button\u0026#34; onclick=\u0026#34;...\u0026#34;\u0026gt;Click me\u0026lt;/button\u0026gt; Code JS trong event dạng này thường chỉ dùng để gọi các function đã định nghĩa trong các script khác (script tag hoặc external js), chứ không phù hợp cho các đoạn code quá dài.\nHead or body?\nScript có thể đặt trong cả head lẫn body. Trước đây người ta khuyến khích đặt ở cuối cùng của body, như sau để cải thiện tốc độ tải trang (vì hạn chế script làm delay việc hiển thị).\n1 2 3 4 5 6 7 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; ... // Script here \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Tuy nhiên, nhờ có thêm thuộc tính defer của tag script nên ta không còn bận tâm vấn đề này nữa. Nhờ có defer, code JS sẽ chỉ thực thi khi trang web đã phân tích xong. Chú ý defer chỉ dành cho tệp JS external.\n3. Output # Có nhiều cách để đưa kết quả ra màn hình để xem. Ví dụ như xem value của biến chẳng hạn. Giống như C++ dùng cout, Java dùng System.out.print() thì JS cũng có những cách riêng để hiển thị output ra bên ngoài. Console.log\nĐưa output ra console của chrome devtools. Cách này khá nhanh và cũng tiện, nó tương tự cout trong C++. Nhược điểm duy nhất là bạn phải nhấn F12 để mở console ra xem.\nMỗi lần gọi, console sẽ in ra theo từng dòng nên bạn không cần quan tâm vấn đề xuống dòng. Và nếu in liên tiếp nhiều giá trị, thì console tự động thêm space tách chúng ra. Bạn không cần làm thủ công.\n1 console.log(10 + 5); Tùy vào loại dữ liệu, khi đưa ra console sẽ được hiển thị khác nhau. Và một điểm rất hay là những loại phức tạp như array, object sẽ được hiển thị trực quan, đầy đủ thông tin cần thiết. Ví dụ, thay vì dùng vòng lặp để in ra mảng như sau.\n1 2 3 let a = [1, 2, 3, 4]; for (let i = 0; i \u0026lt; a.length; i++) console.log(a[i]); Thì chỉ cần\n1 console.log(a); Console sẽ hiển thị đầy đủ dữ liệu, không chỉ có các phần tử mà còn gồm độ dài mảng. Đối với object thì là các key và value thuộc tính. Document.write\nDùng để ghi một đoạn text, hoặc một đoạn HTML ra trang web.\n1 document.write(\u0026#34;Hello\u0026lt;br\u0026gt;\u0026#34;); Nhược điểm là phải ghi đúng HTML format, nếu muốn xuống dòng phải thêm chuỗi \u0026lt;br\u0026gt;. Và chú ý quan trọng, không dùng method này khi trang web tải xong, vì nó sẽ xóa toàn bộ những gì đang có và write lại từ đầu.\nWrite to HTML element\nNgoài ra còn có thể đưa output ra một element nào đó. Ví dụ bạn có một thẻ p, và bạn đưa output ra thẻ này (làm nó hiển thị nội dung output), và bạn có thể đọc được nhờ sự thay đổi trên trang web.\n1 document.getElementById(\u0026#34;test\u0026#34;).innerHTML = 10 + 5; Nhược điểm cách này là khá rườm rà, phải \u0026ldquo;select\u0026rdquo; các element, rồi thay đổi thuộc tính innerHTML của nó. Nó yêu cầu phải tạo thêm một element, với id hay cái gì đó để xác định, nên gây phức tạp cho chương trình.\nWindow.alert()\nNgoài ra có thể dùng method alert() để đưa ra một popup thông báo. Nhưng không được dùng nhiều khi mới học code.\n1 alert(\u0026#34;Hello world\u0026#34;); Nhược điểm là không hiển thị nhiều dữ liệu được, và không hiển thị cùng lúc (vì bị chặn).\nB. JS basic # 1. Statement # Statement hiểu là một câu lệnh. Trong chương trình có nhiều lệnh, và cuối mỗi lệnh nên đặt dấu chấm phẩy để tách ra. Nếu không đặt cũng không sao, thường thì JS không bắt buộc, nhưng khi bạn viết nhiều lệnh trên cùng một dòng thì nên dùng chấm phẩy tách chúng ra. Ví dụ.\n1 2 console.log(a) console.log(b) Mặc dù không cần chấm phẩy, các lệnh trên vẫn hoạt động bình thường, vì nằm trên các dòng khác nhau. Nhưng code sau là sai.\n1 2 console.log(a) console.log(b) // Sai console.log(a); console.log(b); // Ok Quy tắc chúng là nên thêm chấm phấy cuối mỗi lệnh, để tránh rắc rối như sau.\n1 2 3 4 function ABC() { return 10; // Trả về là undefined, chứ không phải 10 } JS sẽ hiểu code trên là như sau, dẫn tới việc sai kết quả.\n1 2 3 4 function ABC() { return; 10; } 2. Comment # Comment bị bỏ qua khi thực thi JS, và có thể dùng comment để giải thích code cho dễ hiểu hơn.\nJS có 2 loại comment là single line comment và multi-line comment (block).\n1 2 3 // This is single line comment /* This is block comment */ Comment dạng 1 comment từ vị trí dấu // cho tới hết dòng. Comment dạng 2 có thể trải rộng trên nhiều dòng, chỉ cần nằm trong cặp/* */sẽ được coi là comment.\nSingle line comment phổ biến hơn, trong khi block comment thường dùng trong documentation.\n3. Variable, constant # Có hai từ khóa khai báo biến là let và var. Vì JS là ngôn ngữ weak type nên không cần chỉ định rõ kiểu của biến, mà được tự động xác định và thay đổi dựa theo value (giá trị) chứa bên trong.\n1 2 3 let x = 10; var y = 1.2; let z; // z = undefined Biến không khởi tạo giá trị sẽ có value là undefined.\nMặc dù cả let và var đều dùng khai báo biến được, nhưng nên dùng let hơn. Chi tiết sẽ được đề cập trong phần cuối chương này.\n1 2 3 let a = 10, b = 1.5, c = \u0026#34;John\u0026#34;; var name = \u0026#34;Mickey\u0026#34;; Biến có thể khai báo trên nhiều dòng, hoặc nhiều biến trên một dòng đều được.\n1 const pi = 3.14; Đối với hằng số (constant) thì dùng từ khóa const như trên để khai báo.\n4. Operators # Toán tử (operator) là những phép tính thực hiện trên các số (biến, hằng, giá trị,\u0026hellip;) gọi là các toán hạng (operand). Kết hợp của toán tử và toán hạng tạo ra những biểu thức (expression) và trả về giá trị nào đó.\nTùy số lượng toán hạng tham gia, được chia thành 3 loại toán tử chính:\nToán tử một ngôi (unary operator): chỉ có một toán hạng, gồm phép thuận +x, phép đối -x và phủ định !x. Toán tử hai ngôi (binary operator): có hai toán hạng, và hầu hết các phép tính số học đều là hai ngôi, như phép * cộng a + b,\u0026hellip; Toán tử ba ngôi (ternary operator): nhận 3 toán hạng, dựa vào toán hạng 1 mà lựa chọn trả về toán hạng 2 hoặc 3. Ngoài ra còn có các toán tử khác, như gán (assignment), logic (logical), so sánh (comparison), thao tác bit (bitwise),\u0026hellip;\nArithmetic operators\nCác phép toán số học trong JS tương tự các ngôn ngữ khác, gồm:\nToán tử một ngôi: +x, lấy số đối -x, tăng ++x, x++, giảm --x, x--. Toán tử hai ngôi: cộng a + b, trừ a - b, nhân a * b, chia nguyên a / b, chia dư a \u0026amp; b. Ngoài ra từ phiên bản ES6 trở đi có phép lũy thừa a ** b để tính số mũ. Assignment operators\nToán tử gán x = 5 tương tự các ngôn ngữ khác. Ngoài ra JS cũng hỗ trợ các phép gán rút gọn như x += 5, x /= 5,\u0026hellip;\nĐặc biệt, JS cho phép gán nhiều giá trị cùng lúc, ví dụ như a = b = c = 5 thì cả 3 biến a, b, c đều mang giá trị 5.\nComparison operators\nGồm các phép so sánh bằng x == 5, khác x != 10 lớn bé, lớn hơn hoặc bằng, bé hơn hoặc bằng như trong các ngôn ngữ khác.\nCác toán tử comparison luôn trả về kết quả boolean.\nNgoài ra JS còn có hai phép so sánh mới là strict comparison x === 10 và x !== 10. Điểm khác biệt ở chỗ strict comparison yêu cầu hai vế phải cùng kiểu dữ liệu thì mới so sánh, nếu khác kiểu thì kết quả là false. Trong khi đó loose comparison x == 10 sẽ tự động convert kiểu phù hợp rồi mới so sánh.\nLogical operators\nDùng cho các toán hạng boolean. Gồm and a \u0026amp;\u0026amp; b, or a || b và not !a.\nBitwise operators\nDùng cho các phép thao tác bit, gồm hai dạng.\nDạng 1 dùng biến đổi bit, gồm 3 toán tử hai ngôi (and x \u0026amp; y, or x | y, xor x ^ y) và một toán tử một ngôi (not !x).\nChú ý các phép trên chỉ sử dụng một dấu, thay vì hai dấu như comparison.\nLoại thứ 2 dùng dịch chuyển bit (bit shifting), gồm left shift (zero fill) x \u0026lt;\u0026lt; n, signed right shift x \u0026gt;\u0026gt; n và zero fill right shift x \u0026gt;\u0026gt;\u0026gt; n.\nTrong JS thì thao tác bit ít dùng.\nC. Data types # 1. Overview # Kiểu dữ liệu (data type) dùng định nghĩa loại dữ liệu mà biến (hoặc hằng) lưu trữ. JS là một ngôn ngữ weak type, nên kiểu dữ liệu không được chỉ định rõ ràng, kiểu được tự động xác định dựa trên giá trị (value) mà nó chứa.\nKiểu dữ liệu của một biến trong JS có thể thay đổi, điều này là không được phép trong các ngôn ngữ strong type.\n1 2 3 let x = 5; // number x = x * 1.5; // number x = x + \u0026#34; VND\u0026#34;; // string Trong JS có một số kiểu như sau:\nNumber: chứa số nguyên và thực Boolean: đúng sai String: chuỗi Object: đối tượng Null Undefined ES6 bổ sung thêm kiểu Symbol nữa. Ngoài ra các kiểu như array, date thực chất cũng là object. Typeof operator\nDùng toán tử typeof để xem kiểu của đối tượng. Kết quả trả về là một string.\nUndefined value\nBiến khi chưa được gán giá trị thì mang value là undefined, và typeof cũng là undefined.\nEmpty value\nCác value rỗng như 0, chuỗi rỗng \u0026ldquo;\u0026rdquo;, null vẫn giữ được kiểu dữ liệu của nó. Ví dụ như sau.\n1 2 3 typeof 0; // number typeof \u0026#34;\u0026#34;; // string typeof null; // object Function type\nCác hàm (function), phương thức (method) cũng là kiểu function, và được xem như các biến. Cả kiểu function và object thuộc loại kiểu phức (complex type).\n1 2 function ABC() {} typeof ABC; // function 2. Type casting # Chuyển đổi kiểu, hay còn gọi là ép kiểu (type casting) là chuyển từ một kiểu này sang kiểu khác. Trong JS, phần nhiều trường hợp sẽ được tự động chuyển (ngầm định - implicit casting), nhưng bạn cũng có thể tự tay ép kiểu theo cách thủ công, rõ ràng (explicit casting).\nCú pháp mặc định cho type casting như sau.\n1 Type(old_var); Ví dụ.\n1 2 3 let x = Number(\u0026#34;100\u0026#34;); // string \u0026gt; number let s1 = String(10); // number \u0026gt; string let s2 = 10.toString(); // number \u0026gt; string Về cơ bản là vậy, bên cạnh đó các kiểu cụ thể sẽ có những method chi tiết hơn để thực hiện chuyển đổi. Ví dụ như từ number sang string thì có những method như toString(), toFixed(), toPrecision() chuyển kiểu nhưng với chức năng khác nhau.\nMột vài lưu ý:\nKhi xuất biến ra console, hoặc element,\u0026hellip; thì JS tự động chuyển thành một string. Trong các biểu thức (expression) tính toán thì JS chuyển kiểu theo một số quy tắc nhất định. Nói chung nên hạn chế type casting, và khi cần thiết nên tránh để JS tự động thực hiện. Hạn chế việc thao tác khác kiểu dữ liệu, vì JS có thể tự động ép kiểu và cho ra kết quả không như mong đợi. D. Basic commands # 1. Conditional statements # If else statement\nLệnh if else trong JS khá giống với các ngôn ngữ khác nên mình không bàn nhiều ở đây.\n1 2 3 4 5 6 if (\u0026lt;condition\u0026gt;) ...; if (\u0026lt;condition\u0026gt;) ... else ... condition là một biểu thức boolean, có được từ phép so sánh hoặc lấy trực tiếp từ biến, hàm. Nếu biểu thức đúng (true), lệnh đầu tiên sẽ được thực hiện, ngược lại thực hiện lệnh thứ 2 (nếu có).\nĐặc biệt, câu lệnh trước else trong JS không cần chấm phẩy cũng được.\nCác cặp if else có thể lồng nhau (nested) như sau, chú ý else if là hai từ riêng biệt.\n1 2 3 4 5 if (\u0026lt;condition1\u0026gt;) ... else if (\u0026lt;condition2\u0026gt;) ... else if (\u0026lt;condition3\u0026gt;) ... ... else ... Các statement nếu là lệnh đơn thì không cần ngoặc, nếu từ 2 lệnh trở lên cần có ngoặc {} bao lại.\nTernary operator\nJS hỗ trợ toán tử ba ngôi (ternary operator) như sau.\n1 \u0026lt;condition\u0026gt; ? \u0026lt;true_value\u0026gt; : \u0026lt;false_value\u0026gt;; Toán tử trả về kết quả là một trong hai value đã cho, dựa theo điều kiện condition. Nếu điều kiện đúng trả về true_value, ngược lại trả về false_value.\nToán tử ternary có thể viết liên tiếp nhau như sau.\n1 2 let x = 10; console.log(x \u0026gt; 0 ? \u0026#39;So duong\u0026#39; : x \u0026lt; 0 ? \u0026#39;So am\u0026#39; : \u0026#39;So khong\u0026#39;); Như code trên so sánh x với 0 và báo x là số dương, số âm hay là 0. Câu lệnh trên dùng hai ternary operator liên tiếp nhau vẫn được.\nSwitch case\nDùng so sánh một biểu thức với nhiều nhóm giá trị khác nhau, mỗi giá trị là một case. Nếu khớp với case nào, thì lệnh trong case sẽ được thực hiện. Còn không có case nào khớp thì default sẽ được gọi (nếu có, vì default có thể bỏ qua)\n1 2 3 4 5 6 7 8 9 10 switch (1 + 2) { case 1: case 2: ... break; case 3: ... break; default: ... } Sau mỗi case nên có break để ngắt, nếu không sẽ bị trôi case, tương tự các ngôn ngữ khác.\nChú ý, switch case sử dụng strict comparison (dấu ===) để so sánh, vì thế nên kiểu dữ liệu của case và expresssion phải giống nhau.\n2. Loop statements # While loop\n1 2 3 while (\u0026lt;condition\u0026gt;) { ... } Lặp lại một công việc với số lần xác định. Nếu điều kiện condition đúng thì lặp lại lần nữa, nếu không thì thoát.\nĐiều kiện dừng cần phải khả thi, để tránh vòng lặp chạy vô hạn sẽ gây crash trình duyệt.\nDo while loop\n1 2 3 do { ... } while (\u0026lt;condition\u0026gt;); Tương tự while loop, nhưng thực hiện ít nhất 1 lần, thực hiện xong lệnh mới kiểm tra điều kiện.\nFor loop\n1 2 for (\u0026lt;init\u0026gt;; \u0026lt;condition\u0026gt;; \u0026lt;increment\u0026gt;) ... Tương tự trong ngôn ngữ khác, nên mình không bàn nhiều ở đây. Ngoài ra JS cho phép các statement bên trong có thể được bỏ qua (omitting).\nOther loop\nHai vòng lặp for nữa trong JS là for of và for in. Ở đây mình ghi ra để làm quen với cú pháp, các bạn có thể bỏ qua, các chương sau sẽ có nhắc tới.\nFor of dùng để duyệt qua lần lượt các element (e) trong một iterable (mảng, chuỗi, map,\u0026hellip;)\n// Viết mã của bạn ở đây Run\n1 2 3 let list = [1, 2, 3, 4]; for (e of list) console.log(e); For indùng lặp qua các thuộc tính của object.\n1 2 3 4 5 6 let obj = { name: \u0026#34;John\u0026#34;, age: 20 } for (p in obj) console.log(p + \u0026#34;: \u0026#34; + obj[p]); Break \u0026amp; continue\nLệnh break dùng để ngắt một vòng lặp, còn continue để dừng lần lặp hiện tại và đi tiếp vòng lặp tiếp theo, tương tự các ngôn ngữ khác.\nNgoải ra break còn dùng cho label để break một label block.\n","date":"12 November 2024","permalink":"/posts/javascript/javascriptblog/blog1/","section":"Danh mục post","summary":"JavaScript series # Chương đầu tiên này sẽ trình bày về những khái niệm căn bản nhất trong JavaScript.","title":"JavaScript căn bản"},{"content":"","date":"12 November 2024","permalink":"/series/","section":"Series","summary":"","title":"Series"},{"content":"","date":"12 November 2024","permalink":"/tags/social/","section":"Tags","summary":"","title":"social"},{"content":"Trong bài đăng trên blog này, chúng tôi sẽ xây dựng một mạng xã hội đơn giản với các tính năng thời gian thực và danh sách tất cả các thành viên đang trực tuyến.\nChúng tôi sẽ sử dụng Node.js làm máy chủ ứng dụng, Vanilla JavaScript ở phía giao diện người dùng và Pusher để giao tiếp thời gian thực giữa máy chủ và phía giao diện người dùng.\nChúng tôi sẽ xây dựng một ứng dụng giống như danh sách bạn bè của bạn hoặc phòng trò chuyện chung, nơi bạn có thể xem ai đang trực tuyến và cập nhật trạng thái mới nhất của họ theo thời gian thực. Trong bài đăng trên blog, chúng ta sẽ tìm hiểu về kênh hiện diện của Pusher và cách biết về các thành viên trực tuyến của kênh này.\nChúng tôi sẽ xây dựng các thành phần sau trong bài đăng trên blog này:\nMáy chủ Node.js sử dụng framework ExpressJS: /registerAPI - Để đăng ký/đăng nhập người dùng mới vào kênh và máy chủ của chúng tôi bằng cách tạo phiên của họ và lưu thông tin của họ /isLoggedInAPI - Để kiểm tra xem người dùng đã đăng nhập hay chưa trong trường hợp làm mới trình duyệt /usersystem/authAPI - Xác thực xác thực được thực hiện bởi Pusher sau khi đăng ký với ứng dụng của chúng tôi và khi đăng ký kênh hiện diện hoặc riêng tư /logoutAPI - Để đăng xuất người dùng và xóa phiên Ứng dụng frontend sử dụng Vanilla JavaScript: Biểu mẫu Đăng ký/Đăng nhập - Để đăng ký/đăng nhập người dùng mới bằng cách điền tên người dùng và trạng thái ban đầu của họ Danh sách thành viên - Để xem tất cả những người đang trực tuyến và trạng thái cập nhật của họ Cập nhật trạng thái - Để nhấp vào trạng thái hiện tại và cập nhật nó trên phần mờ của điều khiển chỉnh sửa văn bản trạng thái Có một số phương thức bạn có thể sử dụng để gửi HTTP request và mỗi phương thức phục vụ một mục đích khác nhau, như được hiển thị bên dưới:\nĐăng ký với Pusher # Bạn có thể tạo một tài khoản miễn phí trong Pusher Tại đây . Sau khi bạn đăng ký và đăng nhập lần đầu tiên, bạn sẽ được yêu cầu tạo một ứng dụng mới như trong hình bên dưới. Bạn sẽ phải điền một số thông tin về dự án của mình và cả thư viện front-end hoặc ngôn ngữ back-end mà bạn sẽ sử dụng để xây dựng ứng dụng.\nĐối với bài đăng blog cụ thể này, chúng tôi sẽ chọn Vanilla JavaScript cho frontend và Node.js cho backend như trong hình trên. Điều này sẽ chỉ hiển thị cho bạn một bộ mã mẫu khởi đầu cho các lựa chọn này, nhưng bạn có thể sử dụng bất kỳ bộ tích hợp nào sau này với ứng dụng này.\nMáy chủ Node.js # Node.js phải được cài đặt trong hệ thống như một điều kiện tiên quyết cho việc này. Bây giờ chúng ta hãy bắt đầu xây dựng máy chủ Node.js và tất cả các API cần thiết bằng Express. Khởi tạo một dự án nút mới bằng lệnh sau\n1 npm init Cài đặt các phụ thuộc # Chúng tôi sẽ cài đặt các phụ thuộc cần thiết như Express, express-session, Pusher, body-parser, cookie-parser bằng lệnh sau:\n1 npm install express express-session body-parser cookie Máy chủ nền tảng # các phiên trong đó bằng cách sử dụng mô-đun express-session.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 var express = require(\u0026#39;express\u0026#39;); var path = require(\u0026#39;path\u0026#39;); var bodyParser = require(\u0026#39;body-parser\u0026#39;); var expressSession = require(\u0026#39;express-session\u0026#39;); var cookieParser = require(\u0026#39;cookie-parser\u0026#39;); var app = express(); // must use cookieParser before expressSession app.use(cookieParser()); app.use(expressSession({ secret:\u0026#39;\u0026lt;some-secret-token-here\u0026gt;\u0026#39;, resave: true, saveUninitialized: true })); app.use(bodyParser.json()); app.use(bodyParser.urlencoded({ extended: false })); app.use(express.static(path.join(__dirname, \u0026#39;public\u0026#39;))); // Error Handler for 404 Pages app.use(function(req, res, next) { var error404 = new Error(\u0026#39;Route Not Found\u0026#39;); error404.status = 404; next(error404); }); module.exports = app; app.listen(9000, function(){ console.log(\u0026#39;Example app listening on port 9000!\u0026#39;) }); Trong đoạn mã trên, chúng tôi đã tạo một máy chủ Express cơ bản và sử dụng phương pháp này, .use chúng tôi đã kích hoạt cookie-parser, body-parser và một tệp tĩnh phục vụ từ public thư mục. Chúng tôi cũng đã kích hoạt các phiên bằng express-session mô-đun. Điều này sẽ cho phép chúng tôi lưu thông tin người dùng trong phiên yêu cầu phù hợp cho người dùng.\nThêm Pusher # Pusher có một mô-đun NPM nguồn mở cho tích hợp Node.js mà chúng ta sẽ sử dụng. Nó cung cấp một tập hợp các phương pháp tiện ích để tích hợp với API Pusher bằng cách sử dụng một appId, khóa và bí mật duy nhất. Đầu tiên, chúng ta sẽ cài đặt npm mô-đun Pusher bằng lệnh sau:\n1 npm install pusher --save Bây giờ, chúng ta có thể sử dụng \u0026lsquo;require\u0026rsquo; để lấy module Pusher và tạo một thể hiện mới bằng cách truyền đối tượng options với các khóa quan trọng để khởi tạo tích hợp của chúng ta. Đối với bài đăng trên blog này, tôi đã đặt các khóa ngẫu nhiên; bạn sẽ phải lấy nó cho ứng dụng của mình từ bảng điều khiển Pusher.\n1 2 3 4 5 6 7 8 9 10 11 var Pusher = require(\u0026#39;pusher\u0026#39;); var pusher = new Pusher({ appId: \u0026#39;30XXX64\u0026#39;, key: \u0026#39;82XXXXXXXXXXXXXXXXXb5\u0026#39;, secret: \u0026#39;7bXXXXXXXXXXXXXXXX9e\u0026#39;, encrypted: true }); var app = express(); ... Bạn sẽ phải thay thế appId, key và a secret bằng các giá trị cụ thể cho ứng dụng của riêng bạn. Sau đó, chúng ta sẽ viết mã cho một API mới sẽ được sử dụng để tạo một bình luận mới.\nĐăng ký/Đăng nhập API # Bây giờ, chúng ta sẽ phát triển tuyến API đầu tiên của ứng dụng, qua đó người dùng mới có thể tự đăng ký/đăng nhập và sử dụng trên ứng dụng của chúng ta.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 app.post(\u0026#39;/register\u0026#39;, function(req, res){ console.log(req.body); if(req.body.username \u0026amp;\u0026amp; req.body.status){ var newMember = { username: req.body.username, status: req.body.status } req.session.user = newMember; res.json({ success: true, error: false }); }else{ res.json({ success: false, error: true, message: \u0026#39;Incomplete information: username and status are required\u0026#39; }); } }); Trong đoạn mã trên, chúng tôi đã đưa ra lệnh gọi API POST trên tuyến đường /register mong đợi các tham số tên người dùng và trạng thái được truyền vào phần thân yêu cầu. Chúng tôi sẽ lưu thông tin người dùng này trong phiên yêu cầu.\nAPI xác thực hệ thống người dùng # Để cho phép bất kỳ máy khách nào đăng ký kênh Pusher Private và Presence, chúng ta cần triển khai API xác thực sẽ xác thực yêu cầu của người dùng bằng cách gọi phương thức Pusher.authenticate ở phía máy chủ. Thêm mã sau vào máy chủ để đáp ứng điều kiện này:\n1 2 3 4 5 6 7 8 9 10 11 12 13 app.post(\u0026#39;/usersystem/auth\u0026#39;, function(req, res) { var socketId = req.body.socket_id; var channel = req.body.channel_name; var currentMember = req.session.user; var presenceData = { user_id: currentMember.username, user_info: { status: currentMember.status, } }; var auth = pusher.authenticate(socketId, channel, presenceData); res.send(auth); }); Chúng ta cần cung cấp tuyến đường cụ thể trong quá trình khởi tạo thư viện phía máy khách Pusher mà chúng ta sẽ thấy sau trong bài đăng trên blog này. Thư viện máy khách Pusher sẽ tự động gọi tuyến đường này và truyền vào các thuộc tính channel_name và socket_id. Chúng ta sẽ đồng thời lấy thông tin người dùng từ đối tượng phiên người dùng và truyền nó dưới dạng presenceData cho lệnh gọi phương thức Pusher.authenticate.\nAPI IsLoggedIn và Logout # Nếu người dùng làm mới trình duyệt, ứng dụng phía máy khách sẽ phát hiện xem người dùng đã đăng ký hay chưa. Chúng tôi sẽ triển khai tuyến API isLoggedIn cho việc này. Ngoài ra, chúng tôi cần tuyến đăng xuất để cho phép bất kỳ người dùng nào đăng xuất khỏi ứng dụng.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 app.get(\u0026#39;/isLoggedIn\u0026#39;, function(req,res){ if(req.session.user){ res.send({ authenticated: true }); }else{ res.send({ authenticated: false }); } }); app.get(\u0026#39;/logout\u0026#39;, function(req,res){ if(req.session.user){ req.session.user = null; } res.redirect(\u0026#39;/\u0026#39;); }); Ứng dụng frontend sử dụng Vanilla JavaScript # Chúng tôi sẽ phát triển ứng dụng front-end ngay bây giờ để đăng ký người dùng mới với trạng thái ban đầu, xem các thành viên đang trực tuyến và trạng thái của họ. Chúng tôi cũng sẽ xây dựng tính năng cho người dùng đã đăng nhập để cập nhật người dùng của họ và tất cả người dùng khác sẽ thấy trạng thái được cập nhật theo thời gian thực.\nBước 1: Tạo một thư mục có tên là public và tạo một index.html # Chúng tôi đã viết mã server.js để phục vụ nội dung tĩnh từ public thư mục, vì vậy chúng tôi sẽ viết toàn bộ mã giao diện người dùng vào thư mục này.\nVui lòng tạo một thư mục mới public và cũng tạo một thư mục trống index.html ngay bây giờ.\nBước 2: Thêm mã mẫu vào index.html của chúng tôi # Chúng tôi sẽ thêm một số mã mẫu cơ bản để thiết lập cấu trúc cơ sở cho ứng dụng web của chúng tôi như Tiêu đề, Mục nơi có thể đặt biểu mẫu đăng ký và danh sách thành viên.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 \u0026lt;!DOCTYPE\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Whats Up ! Know what other\u0026#39;s are up to in Realtime !\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://unpkg.com/purecss@0.6.2/build/pure-min.css\u0026#34; integrity=\u0026#34;sha384-UQiGfs9ICog+LwheBSRCt1o5cbyKIHbwjWscjemyBMT9YCUMZffs6UqUTd0hObXD\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://fonts.googleapis.com/css?family=Raleway:200\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;./style.css\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;header\u0026gt; \u0026lt;div class=\u0026#34;logo\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;./assets/pusher-logo.png\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;logout\u0026#34; class=\u0026#34;logout\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;/logout\u0026#34;\u0026gt;Logout\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;section class=\u0026#34;subheader\u0026#34;\u0026gt; \u0026lt;img class=\u0026#34;whatsup-logo\u0026#34; src=\u0026#34;./assets/whatsup.png\u0026#34; /\u0026gt; \u0026lt;h2\u0026gt;Whats Up ! Know what other\u0026#39;s are up to in Realtime !\u0026lt;/h2\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section\u0026gt; \u0026lt;div id=\u0026#34;loader\u0026#34; class=\u0026#34;loader\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script id=\u0026#34;member-template\u0026#34; type=\u0026#34;text/x-template\u0026#34;\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;div id=\u0026#34;me\u0026#34; class=\u0026#34;me\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;membersList\u0026#34; class=\u0026#34;members-list\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;signup-form\u0026#34; class=\u0026#34;tab-content\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;header\u0026#34;\u0026gt; \u0026lt;div\u0026gt;\u0026lt;img src=\u0026#34;./assets/comments.png\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;text\u0026#34;\u0026gt;First Time Sign Up !\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;form class=\u0026#34;pure-form\u0026#34; id=\u0026#34;user-form\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;signup-form\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;left-side\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; required placeholder=\u0026#34;enter a username or displayname\u0026#34; id=\u0026#34;display_name\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;textarea placeholder=\u0026#34;enter initial status text\u0026#34; required id=\u0026#34;initial_status\u0026#34; rows=\u0026#34;3\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;right-side\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; class=\u0026#34;button-secondary pure-button\u0026#34;\u0026gt;Signup/Login\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;script src=\u0026#34;https://js.pusher.com/4.0/pusher.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./app.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Trong đoạn mã boilerplate ở trên, chúng tôi đã tham chiếu đến tệp Javascript chính app.js và thư viện JS phía máy khách Pusher. Chúng tôi cũng có một thẻ script nơi chúng tôi sẽ đặt mẫu cho một hàng thành viên trong danh sách thành viên. Ngoài ra, chúng tôi có hai thẻ div trống với id là me và membersList để chứa tên và thông tin thành viên đã đăng nhập, cũng như danh sách tất cả các thành viên khác cùng với trạng thái của họ.\nBước 3: Style.css # Điều quan trọng cần lưu ý là chúng tôi sẽ hiển thị biểu mẫu đăng ký lần đầu tiên và nút MembersList và Logout sẽ bị ẩn theo mặc định ban đầu. Vui lòng tạo một tệp mới có tên style.css và thêm css sau vào đó:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 body{ margin:0; padding:0; overflow: hidden; font-family: Raleway; } header{ background: #2b303b; height: 50px; width:100%; display: flex; color:#fff; } .loader, .loader:after { border-radius: 50%; width: 10em; height: 10em; } .loader { margin: 60px auto; font-size: 10px; position: relative; text-indent: -9999em; border-top: 1.1em solid rgba(82,0,115, 0.2); border-right: 1.1em solid rgba(82,0,115, 0.2); border-bottom: 1.1em solid rgba(82,0,115, 0.2); border-left: 1.1em solid #520073; -webkit-transform: translateZ(0); -ms-transform: translateZ(0); transform: translateZ(0); -webkit-animation: load8 1.1s infinite linear; animation: load8 1.1s infinite linear; } @-webkit-keyframes load8 { 0% { -webkit-transform: rotate(0deg); transform: rotate(0deg); } 100% { -webkit-transform: rotate(360deg); transform: rotate(360deg); } } @keyframes load8 { 0% { -webkit-transform: rotate(0deg); transform: rotate(0deg); } 100% { -webkit-transform: rotate(360deg); transform: rotate(360deg); } } .subheader{ display: flex; align-items: center; margin: 0px; } .whatsup-logo{ height:60px; border-radius: 8px; flex:0 60px; margin-right: 15px; } .logout{ flex:1; justify-content: flex-end; padding:15px; display: none; } .logout a{ color:#fff; text-decoration: none; } #signup-form{ display: none; } input, textarea{ width:100%; } section{ padding: 0px 15px; } .logo img{ height: 35px; padding: 6px; margin-left: 20px; } #updateStatus{ display: none; } .members-list{ display: none; flex-direction: column; } .me { display: none; } Vui lòng thử mở URL http://localhost:9000 trong trình duyệt của bạn và ứng dụng sẽ tải với biểu mẫu đăng ký hoặc đăng nhập cơ bản với tên người dùng và trạng thái. Đầu ra sẽ trông giống như ảnh chụp màn hình bên dưới: Bước 4: Thêm mã cơ bản app.js # Bây giờ chúng ta sẽ thêm mã Javascript để có các thành phần tiện ích cơ bản bên trong một hàm tự gọi để tạo phạm vi riêng cho các biến ứng dụng của chúng ta. Chúng ta không muốn làm ô nhiễm phạm vi toàn cục của JS.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 // Using IIFE for Implementing Module Pattern to keep the Local Space for the JS Variables (function() { // Enable pusher logging - don\u0026#39;t include this in production Pusher.logToConsole = true; var serverUrl = \u0026#34;/\u0026#34;, members = [], pusher = new Pusher(\u0026#39;73xxxxxxxxxxxxxxxdb\u0026#39;, { authEndpoint: \u0026#39;/usersystem/auth\u0026#39;, encrypted: true }), channel, userForm = document.getElementById(\u0026#34;user-form\u0026#34;), memberTemplateStr = document.getElementById(\u0026#39;member-template\u0026#39;).innerHTML; function showEle(elementId){ document.getElementById(elementId).style.display = \u0026#39;flex\u0026#39;; } function hideEle(elementId){ document.getElementById(elementId).style.display = \u0026#39;none\u0026#39;; } function ajax(url, method, payload, successCallback){ var xhr = new XMLHttpRequest(); xhr.open(method, url, true); xhr.setRequestHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json;charset=UTF-8\u0026#34;); xhr.onreadystatechange = function () { if (xhr.readyState != 4 || xhr.status != 200) return; successCallback(xhr.responseText); }; xhr.send(JSON.stringify(payload)); } ajax(serverUrl+\u0026#34;isLoggedIn\u0026#34;,\u0026#34;GET\u0026#34;,{},isLoginChecked); function isLoginChecked(response){ var responseObj = JSON.parse(response); if(responseObj.authenticated){ channel = pusher.subscribe(\u0026#39;presence-whatsup-members\u0026#39;); bindChannelEvents(channel); } updateUserViewState(responseObj.authenticated); } function updateUserViewState(isLoggedIn){ document.getElementById(\u0026#34;loader\u0026#34;).style.display = \u0026#34;none\u0026#34;; if(isLoggedIn){ document.getElementById(\u0026#34;logout\u0026#34;).style.display = \u0026#34;flex\u0026#34;; document.getElementById(\u0026#34;signup-form\u0026#34;).style.display = \u0026#34;none\u0026#34;; }else{ document.getElementById(\u0026#34;logout\u0026#34;).style.display = \u0026#34;none\u0026#34;; document.getElementById(\u0026#34;signup-form\u0026#34;).style.display = \u0026#34;block\u0026#34;; } } function showLoader(){ document.getElementById(\u0026#34;loader\u0026#34;).style.display = \u0026#34;block\u0026#34;; document.getElementById(\u0026#34;logout\u0026#34;).style.display = \u0026#34;none\u0026#34;; document.getElementById(\u0026#34;signup-form\u0026#34;).style.display = \u0026#34;none\u0026#34;; } // Adding a new Member Form Submit Event userForm.addEventListener(\u0026#34;submit\u0026#34;, addNewMember); function addNewMember(event){ event.preventDefault(); var newMember = { \u0026#34;username\u0026#34;: document.getElementById(\u0026#39;display_name\u0026#39;).value, \u0026#34;status\u0026#34;: document.getElementById(\u0026#39;initial_status\u0026#39;).value } showLoader(); ajax(serverUrl+\u0026#34;register\u0026#34;,\u0026#34;POST\u0026#34;,newMember, onMemberAddSuccess); } function onMemberAddSuccess(response){ // On Success of registering a new member console.log(\u0026#34;Success: \u0026#34; + response); userForm.reset(); updateUserViewState(true); // Subscribing to the \u0026#39;presence-members\u0026#39; Channel channel = pusher.subscribe(\u0026#39;presence-whatsup-members\u0026#39;); bindChannelEvents(channel); } })(); Trong đoạn mã trên, chúng ta đã tham chiếu đến tất cả các biến quan trọng mà chúng ta sẽ yêu cầu. Chúng ta cũng sẽ khởi tạo thư viện Pusher bằng cách sử dụng Pusher mới và truyền khóa api làm đối số đầu tiên. Đối số thứ hai chứa một đối tượng cấu hình tùy chọn trong đó chúng ta sẽ thêm khóa authEndpoint với tuyến api nút tùy chỉnh /usersystem/auth và cũng thêm khóa encrypted thiết lập giá trị true.\nChúng tôi sẽ tạo một vài hàm chung để hiển thị hoặc ẩn một phần tử bằng cách truyền id duy nhất của nó. Chúng tôi cũng đã thêm một phương thức chung có tên là ajax để thực hiện các yêu cầu ajax bằng đối tượng XMLHttp trong Vanilla JavaScript.\nKhi tải trang, chúng tôi thực hiện yêu cầu ajax để kiểm tra xem người dùng đã đăng nhập hay chưa. Nếu người dùng đã đăng nhập, chúng tôi sẽ trực tiếp sử dụng phiên bản Pusher để đăng ký người dùng vào kênh hiện diện có tên là presence-whatsup-members, bạn có thể có kênh này làm phòng trò chuyện hoặc vị trí ứng dụng duy nhất mà bạn muốn báo cáo/theo dõi các thành viên trực tuyến.\nChúng tôi cũng đã viết một phương pháp ở trên để addNewMember sử dụng yêu cầu ajax đến register tuyến api mà chúng tôi đã xây dựng trong Node.js. Chúng tôi sẽ truyền tên và trạng thái ban đầu được nhập vào biểu mẫu.\nChúng tôi cũng có một phương pháp để cập nhật trạng thái xem của người dùng dựa trên trạng thái đã đăng nhập. Phương pháp này không làm gì ngoài việc cập nhật khả năng hiển thị của danh sách thành viên, nút đăng xuất và biểu mẫu đăng ký. Chúng tôi đã sử dụng một bindChannelEvents phương pháp khi người dùng đã đăng nhập mà chúng tôi sẽ triển khai sau trong bài đăng trên blog.\nVui lòng thêm đoạn css sau vào style.css tệp để hiển thị me phần tử phù hợp với tên người dùng và trạng thái của người dùng đã đăng nhập.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 .me { border:1px solid #aeaeae; padding:10px; margin:10px; border-radius: 10px; } .me img{ height: 40px; width: 40px; } .me .status{ padding:5px; flex:1; } .me .status .username{ font-size:13px; color: #aeaeae; margin-bottom:5px; } .me .status .text{ font-size: 15px; width:100%; -webkit-transition: all 1s ease-in 5ms; -moz-transition: all 1s ease-in 5ms; transition: all 1s ease-in 5ms; } Bước 5: Thêm mã để hiển thị danh sách thành viên và bindChannelEvents # Bây giờ, sau khi đăng ký kênh, chúng ta cần liên kết một số sự kiện nhất định để có thể biết khi nào có thành viên mới được thêm vào kênh hoặc xóa khỏi kênh. Chúng ta cũng sẽ liên kết với một sự kiện tùy chỉnh để biết khi nào có người cập nhật trạng thái của họ.\nThêm đoạn mã sau vào app.js tệp:\n1 2 3 4 5 6 7 8 9 10 11 // Binding to Pusher Events on our \u0026#39;presence-whatsup-members\u0026#39; Channel function bindChannelEvents(channel){ channel.bind(\u0026#39;client-status-update\u0026#39;,statusUpdated); var reRenderMembers = function(member){ renderMembers(channel.members); } channel.bind(\u0026#39;pusher:subscription_succeeded\u0026#39;, reRenderMembers); channel.bind(\u0026#39;pusher:member_added\u0026#39;, reRenderMembers); channel.bind(\u0026#39;pusher:member_removed\u0026#39;, reRenderMembers); } Trong phương pháp trên bindChannelEvents, chúng ta sử dụng channel.bind phương pháp này để liên kết trình xử lý sự kiện cho 3 sự kiện nội bộ - pusher:subscription_succeeded, pusher:member_added, pusher:member_removed và 1 sự kiện tùy chỉnh - client-status-update.\nBây giờ chúng ta sẽ thêm mã JavaScript để hiển thị danh sách thành viên. Điều quan trọng là phải biết rằng đối tượng mà tôi trả về từ .subscribe phương thức có một thuộc tính được gọi members là có thể được sử dụng để biết thông tin về người dùng đã đăng nhập được tham chiếu bởi khóa me và các thành viên khác theo khóa members. Thêm mã sau vào app.js tệp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // Render the list of members with updated data and also render the logged in user component function renderMembers(channelMembers){ var members = channelMembers.members; var membersListNode = document.createElement(\u0026#39;div\u0026#39;); showEle(\u0026#39;membersList\u0026#39;); Object.keys(members).map(function(currentMember){ if(currentMember !== channelMembers.me.id){ var currentMemberHtml = memberTemplateStr; currentMemberHtml = currentMemberHtml.replace(\u0026#39;{{username}}\u0026#39;,currentMember); currentMemberHtml = currentMemberHtml.replace(\u0026#39;{{status}}\u0026#39;,members[currentMember].status); currentMemberHtml = currentMemberHtml.replace(\u0026#39;{{time}}\u0026#39;,\u0026#39;\u0026#39;); var newMemberNode = document.createElement(\u0026#39;div\u0026#39;); newMemberNode.classList.add(\u0026#39;member\u0026#39;); newMemberNode.setAttribute(\u0026#34;id\u0026#34;,\u0026#34;user-\u0026#34;+currentMember); newMemberNode.innerHTML = currentMemberHtml; membersListNode.appendChild(newMemberNode); } }); renderMe(channelMembers.me); document.getElementById(\u0026#34;membersList\u0026#34;).innerHTML = membersListNode.innerHTML; } function renderMe(myObj){ document.getElementById(\u0026#39;myusername\u0026#39;).innerHTML = myObj.id; document.getElementById(\u0026#39;mystatus\u0026#39;).innerHTML = myObj.info.status; } Chúng tôi đã thêm trình xử lý sự kiện cho sự kiện thêm/xóa thành viên mới để hiển thị lại danh sách thành viên để danh sách này chỉ được cập nhật với các thành viên trực tuyến. Để hiển thị danh sách thành viên, chúng tôi cần thêm kiểu sau vào tệp của mình style.css.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 .member{ display: flex; border-bottom: 1px solid #aeaeae; margin-bottom: 10px; padding: 10px; } .member .user-icon{ flex:0 40px; display: flex; align-items: center; justify-content: center; } .member .user-icon img{ width:50px; height:50px; } .member .user-info{ padding:5px; margin-left:10px; } .member .user-info .name{ font-weight: bold; font-size: 16px; padding-bottom:5px; } .member .user-info .status{ font-weight: normal; font-size:13px; } .member .user-info .time{ font-weight: normal; font-size:10px; color:#aeaeae; } Bây giờ chúng ta sẽ viết mã để kích hoạt sự kiện máy khách trên kênh của chúng ta để thông báo cho tất cả người dùng về sự thay đổi trạng thái của người dùng đã đăng nhập. Thêm mã sau vào app.js tệp của bạn.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // On Blur of editting my status update the status by sending Pusher event document.getElementById(\u0026#39;mystatus\u0026#39;).addEventListener(\u0026#39;blur\u0026#39;,sendStatusUpdateReq); function sendStatusUpdateReq(event){ var newStatus = document.getElementById(\u0026#39;mystatus\u0026#39;).innerHTML; var username = document.getElementById(\u0026#39;myusername\u0026#39;).innerText; channel.trigger(\u0026#34;client-status-update\u0026#34;, { username: username, status: newStatus }); } // New Update Event Handler // We will take the Comment Template, replace placeholders and append to commentsList function statusUpdated(data){ var updatedMemberHtml = memberTemplateStr; updatedMemberHtml = updatedMemberHtml.replace(\u0026#39;{{username}}\u0026#39;,data.username); updatedMemberHtml = updatedMemberHtml.replace(\u0026#39;{{status}}\u0026#39;,data.status); updatedMemberHtml = updatedMemberHtml.replace(\u0026#39;{{time}}\u0026#39;,\u0026#39;just now\u0026#39;); document.getElementById(\u0026#34;user-\u0026#34;+data.username).style.color = \u0026#39;#1B8D98\u0026#39;; document.getElementById(\u0026#34;user-\u0026#34;+data.username).innerHTML=updatedMemberHtml; setTimeout(function(){ document.getElementById(\u0026#34;user-\u0026#34;+data.username).style.color = \u0026#39;#000\u0026#39;; },500); } QUAN TRỌNG : Khi chúng ta chạy mã này trong trình duyệt của mình, cập nhật trạng thái và làm mờ điều khiển trạng thái, chúng ta sẽ gặp lỗi trong bảng điều khiển JavaScript cho thư viện Pusher. Để khắc phục lỗi này, hãy vào bảng điều khiển tại trang web Pusher.com, vào cài đặt và bật gửi sự kiện trực tiếp từ máy khách.\n1 2 3 4 5 6 7 8 9 10 11 Pusher : Error : { \u0026#34;type\u0026#34;:\u0026#34;WebSocketError\u0026#34;, \u0026#34;error\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;PusherError\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;code\u0026#34;:null, \u0026#34;message\u0026#34;:\u0026#34;To send client events, you must enable this feature in the Settings page of your dashboard.\u0026#34; } } } Phần kết luận # Chúng tôi đã xây dựng một ứng dụng sẽ hiển thị tất cả các thành viên trực tuyến cho một kênh hiện diện cụ thể và các cập nhật của họ. Nếu bất kỳ người dùng trực tuyến nào cập nhật trạng thái của họ, mọi người dùng sẽ được thông báo về trạng thái đã cập nhật.\nThành phần hoặc mã này có thể được sử dụng để phát triển phần mạng xã hội trong hầu hết các ứng dụng web hiện nay. Đây là trường hợp sử dụng quan trọng khi người dùng cần biết về những người tham gia khác có sẵn. Ví dụ: ứng dụng lớp học trực tuyến có thể thấy những người tham gia khác và trạng thái có thể tương ứng với bất kỳ câu hỏi nào mà bất kỳ người tham gia nào muốn hỏi người thuyết trình.\n","date":"12 November 2024","permalink":"/posts/javascript/javascriptblog/blog3/","section":"Danh mục post","summary":"Trong bài đăng trên blog này, chúng tôi sẽ xây dựng một mạng xã hội đơn giản với các tính năng thời gian thực và danh sách tất cả các thành viên đang trực tuyến.","title":"Xây dựng một mạng xã hội đơn giản với JavaScript"},{"content":" Cách cắt chuỗi trong Java # Cắt chuỗi là thao tác trích xuất một phần cụ thể của chuỗi dựa trên vị trí bắt đầu và (tùy chọn) vị trí kết thúc.\nTrong Java, có hai cách chính để cắt chuỗi:\nSử dụng chỉ số: Sử dụng dấu ngoặc vuông ([]) với chỉ số bắt đầu và kết thúc để trích xuất phần chuỗi mong muốn. Sử dụng phương thức substring(): Phương thức này cho phép bạn chỉ định vị trí bắt đầu và vị trí kết thúc tùy ý. Hàm cắt chuỗi # Java cung cấp nhiều hàm tích hợp sẵn để xử lý chuỗi, bao gồm cắt chuỗi:\nsubstring(int startIndex): Trích xuất phần chuỗi từ vị trí bắt đầu đã chỉ định đến cuối chuỗi. substring(int startIndex, int endIndex): Trích xuất phần chuỗi từ vị trí bắt đầu đến trước vị trí kết thúc đã chỉ định. split(String delimiter): Chia chuỗi thành một mảng các chuỗi con dựa trên một ký tự phân cách. replace(String oldChar, String newChar): Thay thế tất cả các lần xuất hiện của oldChar bằng newChar trong chuỗi. Ví dụ về cắt chuỗi trong Java # Để hiểu rõ hơn về cách cắt chuỗi trong Java, chúng ta hãy xem một ví dụ đơn giản. Giả sử chúng ta có một chuỗi “Hello World”, chúng ta muốn cắt chuỗi này để lấy ra từ “World”.\nSử dụng chỉ số:\n1 2 String str = \u0026#34;Hello World\u0026#34;; String result = str.substring(6); // result = \u0026#34;World\u0026#34; Ở đây, chúng ta sử dụng chỉ số 6 để chỉ định vị trí bắt đầu của chuỗi con mà chúng ta muốn trích xuất. Lưu ý rằng chỉ số bắt đầu từ 0, nên vị trí thứ 6 trong chuỗi sẽ là ký tự “W”.\nSử dụng phương thức substring():\n1 2 String str = \u0026#34;Hello World\u0026#34;; String result = str.substring(6, 11); // result = \u0026#34;World\u0026#34; Ở đây, chúng ta sử dụng hai tham số là 6 và 11 để chỉ định vị trí bắt đầu và kết thúc của chuỗi con mà chúng ta muốn trích xuất. Lưu ý rằng vị trí kết thúc không được bao gồm trong chuỗi con trả về, nên chúng ta cần chỉ định vị trí kết thúc là 11 để lấy được từ “World”.\nThao tác cắt chuỗi # Ngoài việc trích xuất một phần của chuỗi, chúng ta còn có thể thực hiện các thao tác khác trên chuỗi bằng cách cắt chuỗi. Ví dụ, chúng ta có thể chia chuỗi thành các chuỗi con dựa trên một ký tự phân cách hoặc thay thế một ký tự trong chuỗi bằng một ký tự khác.\nĐể minh họa cho các thao tác này, chúng ta sẽ sử dụng chuỗi “apple,banana,orange”.\nChia chuỗi thành một mảng các chuỗi con\nĐể chia chuỗi thành một mảng các chuỗi con dựa trên một ký tự phân cách, chúng ta sử dụng phương thức split().\n1 2 String str = \u0026#34;apple,banana,orange\u0026#34;; String[] fruits = str.split(\u0026#34;,\u0026#34;); // fruits = [\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;orange\u0026#34;] Ở đây, chúng ta sử dụng ký tự , làm ký tự phân cách để chia chuỗi thành các chuỗi con. Kết quả trả về là một mảng các chuỗi con được lưu trong biến fruits.\nThay thế ký tự trong chuỗi\nĐể thay thế tất cả các lần xuất hiện của một ký tự trong chuỗi bằng một ký tự khác, chúng ta sử dụng phương thức replace().\n1 2 String str = \u0026#34;apple,banana,orange\u0026#34;; String newStr = str.replace(\u0026#34;,\u0026#34;, \u0026#34;;\u0026#34;); // newStr = \u0026#34;apple;banana;orange\u0026#34; Ở đây, chúng ta thay thế tất cả các lần xuất hiện của ký tự , bằng ký tự ;. Kết quả trả về là một chuỗi mới được lưu trong biến newStr.\nCác phương thức cắt chuỗi # Trong phần trước, chúng ta đã tìm hiểu về các phương thức cắt chuỗi trong Java. Trong phần này, chúng ta sẽ đi sâu hơn vào các phương thức này và tìm hiểu cách sử dụng chúng.\nCách sử dụng hàm cắt chuỗi trong Java # Để sử dụng các phương thức cắt chuỗi trong Java, chúng ta cần khởi tạo một đối tượng String từ chuỗi cần xử lý. Sau đó, chúng ta có thể gọi các phương thức trên đối tượng này để thực hiện các thao tác cắt chuỗi.\nVí dụ:\n1 2 String str = \u0026#34;Hello World\u0026#34;; String result = str.substring(6); // result = \u0026#34;World\u0026#34; Ở đây, chúng ta đã khởi tạo đối tượng String từ chuỗi “Hello World” và gọi phương thức substring() để cắt chuỗi từ vị trí thứ 6 đến cuối chuỗi.\nLưu ý khi cắt chuỗi # Khi sử dụng các phương thức cắt chuỗi trong Java, chúng ta cần lưu ý một số điểm sau:\nChỉ số bắt đầu từ 0: Khi sử dụng chỉ số để cắt chuỗi, chúng ta cần nhớ rằng chỉ số bắt đầu từ 0, nên vị trí thứ 6 trong chuỗi sẽ là ký tự thứ 7. Vị trí kết thúc không được bao gồm: Khi sử dụng phương thức substring(), vị trí kết thúc không được bao gồm trong chuỗi con trả về. Vì vậy, chúng ta cần chỉ định vị trí kết thúc là một số lớn hơn vị trí thực tế một đơn vị. Chuỗi là không thay đổi: Các phương thức cắt chuỗi trong Java không làm thay đổi chuỗi gốc, mà trả về một chuỗi mới. Vì vậy, nếu chúng ta muốn thay đổi chuỗi gốc, chúng ta cần gán lại giá trị trả về cho chuỗi gốc. Các ví dụ thực tế về cắt chuỗi trong Java # Để hiểu rõ hơn về cách sử dụng các phương thức cắt chuỗi trong Java, chúng ta sẽ xem một số ví dụ thực tế sau:\nLấy tên file từ đường dẫn đầy đủ: 1 2 String path = \u0026#34;/home/user/documents/report.pdf\u0026#34;; String fileName = path.substring(path.lastIndexOf(\u0026#34;/\u0026#34;) + 1); // fileName = \u0026#34;report.pdf\u0026#34; Ở đây, chúng ta sử dụng phương thức lastIndexOf() để tìm vị trí của ký tự / cuối cùng trong đường dẫn và cắt chuỗi từ vị trí đó đến cuối chuỗi để lấy ra tên file.\nChuyển đổi ngày tháng năm thành chuỗi ngày/tháng/năm: 1 2 3 String date = \u0026#34;2024-03-09\u0026#34;; String[] parts = date.split(\u0026#34;-\u0026#34;); String newDate = parts[2] + \u0026#34;/\u0026#34; + parts[1] + \u0026#34;/\u0026#34; + parts[0]; // newDate = \u0026#34;09/03/2024\u0026#34; Ở đây, chúng ta sử dụng phương thức split() để chia chuỗi thành một mảng các chuỗi con dựa trên ký tự -. Sau đó, chúng ta sử dụng các phần tử trong mảng này để tạo ra chuỗi mới có định dạng ngày/tháng/năm.\nSo sánh các cách cắt chuỗi trong Java # Có hai cách chính để cắt chuỗi trong Java là sử dụng chỉ số và sử dụng phương thức substring(). Cả hai cách này đều có những ưu điểm và hạn chế riêng, vì vậy chúng ta cần cân nhắc để chọn cách phù hợp cho từng tình huống.\nSử dụng chỉ số:\nƯu điểm: Đơn giản và dễ hiểu.\nHạn chế: Chỉ có thể cắt chuỗi theo vị trí bắt đầu và kết thúc đã biết trước. Sử dụng phương thức substring():\nƯu điểm: Linh hoạt, có thể cắt chuỗi theo vị trí bất kỳ.\nHạn chế: Phức tạp hơn khi cần cắt chuỗi theo nhiều vị trí khác nhau. Vì vậy, chúng ta cần cân nhắc các yếu tố như tính đơn giản, tính linh hoạt và hiệu suất để chọn cách cắt chuỗi phù hợp cho từng tình huống.\nTài liệu tham khảo # Các phương thức cắt chuỗi trong Java ","date":"23 June 2024","permalink":"/posts/java/javablog/blog3/","section":"Danh mục post","summary":"Cách cắt chuỗi trong Java # Cắt chuỗi là thao tác trích xuất một phần cụ thể của chuỗi dựa trên vị trí bắt đầu và (tùy chọn) vị trí kết thúc.","title":"Các phương thức cắt chuỗi trong Java"},{"content":" Tìm hiểu về tính năng protected trong Java # Tính năng protected trong Java cho phép các thành phần của một lớp được truy cập bởi các lớp con của nó.\nĐiều này có nghĩa là các lớp con có thể sử dụng và mở rộng các thành phần protected của lớp cha. Điều này rất hữu ích khi chúng ta muốn tạo ra các lớp con có tính kế thừa từ lớp cha mà không cần phải viết lại code.\nĐể sử dụng tính năng protected trong Java, chúng ta có thể sử dụng cú pháp sau:\n1 2 protected [kiểu dữ liệu] [tên biến]; protected [kiểu trả về] [tên phương thức]([tham số]); Các thành phần được đánh dấu là protected có thể được truy cập bởi:\nBản thân lớp sở hữu các thành phần protected Các lớp con của lớp cha Các lớp trong cùng một gói với lớp cha (nếu không có modifier truy cập nào khác được chỉ định) Cách sử dụng từ khóa protected trong Java # Để minh hoạ cách sử dụng tính năng protected trong Java, chúng ta sẽ tạo ra một ví dụ đơn giản về lớp cha và lớp con. Trong ví dụ này, chúng ta sẽ tạo ra một lớp cha có tên là Shape và một lớp con là Rectangle.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class Shape { protected int width; protected int height; public Shape(int width, int height) { this.width = width; this.height = height; } protected int calculateArea() { return this.width * this.height; } } public class Rectangle extends Shape { private String color; public Rectangle(int width, int height, String color) { super(width, height); this.color = color; } public void printArea() { System.out.println(\u0026#34;Area of rectangle is: \u0026#34; + calculateArea()); } } Trong ví dụ trên, chúng ta có một lớp cha Shape với hai thuộc tính là width và height, cùng với một phương thức tính diện tích là calculateArea(). Lớp con Rectangle kế thừa từ lớp cha Shape và sử dụng các thuộc tính và phương thức protected của nó.\nChúng ta có thể thấy rằng trong lớp con Rectangle, chúng ta không cần phải khai báo lại các thuộc tính và phương thức đã có sẵn trong lớp cha. Thay vào đó, chúng ta chỉ cần gọi các phương thức và thuộc tính đó thông qua từ khóa super.\n1 2 3 public void printArea() { System.out.println(\u0026#34;Area of rectangle is: \u0026#34; + calculateArea()); } Phân biệt giữa private và protected trong Java # Sự khác biệt chính giữa private và protected là phạm vi truy cập:\nPrivate: Các thành phần private chỉ có thể được truy cập từ bên trong lớp sở hữu chúng. Protected: Các thành phần protected có thể được truy cập bởi lớp sở hữu chúng, các lớp con và các lớp khác trong cùng một gói. Điều này có nghĩa là khi chúng ta sử dụng từ khóa private, các thành phần đó chỉ có thể được truy cập bởi lớp sở hữu của chúng. Trong khi đó, khi sử dụng từ khóa protected, các thành phần có thể được truy cập bởi nhiều lớp hơn, bao gồm cả lớp con và các lớp trong cùng một gói. Lợi ích của việc sử dụng protected trong Java # Sử dụng tính năng protected mang lại một số lợi ích:\nTính kế thừa dễ dàng: Cho phép các lớp con tiếp tục sử dụng và mở rộng các thành phần protected của lớp cha. Giảm thiểu code: Không cần phải viết lại code cho các thành phần đã có sẵn trong lớp cha. Bảo mật dữ liệu: Các thành phần protected chỉ có thể được truy cập bởi các lớp có quyền truy cập tương đương, giúp bảo vệ dữ liệu của lớp cha. Các quy tắc và hạn chế khi sử dụng protected trong Java # Khi sử dụng tính năng protected trong Java, chúng ta cần lưu ý một số quy tắc và hạn chế sau:\nCác thành phần protected không thể được truy cập từ bên ngoài gói chứa lớp cha, trừ khi lớp con của nó cũng nằm trong gói đó. Các thành phần protected không thể được truy cập từ bên ngoài lớp con, trừ khi lớp con đó là lớp con của lớp cha đó. Các thành phần protected không thể được truy cập từ bên ngoài lớp con của lớp con, trừ khi lớp con đó là lớp con của lớp cha và nằm trong cùng một gói với lớp cha. Bảo mật dữ liệu với tính năng protected trong Java # Một trong những ứng dụng quan trọng của tính năng protected trong Java là để bảo mật dữ liệu. Với tính năng này, chúng ta có thể giới hạn quyền truy cập vào các thành phần của lớp chỉ cho các lớp có quyền truy cập tương đương. Điều này giúp bảo vệ dữ liệu của lớp cha khỏi việc bị sửa đổi hoặc truy cập trái phép.\nVí dụ, trong lớp Shape ở ví dụ trước, chúng ta có thể sử dụng tính năng protected để bảo vệ các thuộc tính width và height của lớp. Điều này đảm bảo rằng chỉ có các lớp con của Shape mới có thể truy cập và sử dụng các thuộc tính này.\nVí dụ minh họa về cách sử dụng protected trong Java # Để hiểu rõ hơn về cách sử dụng tính năng protected trong Java, chúng ta sẽ xem xét một ví dụ khác. Trong ví dụ này, chúng ta sẽ tạo ra một lớp Employee và một lớp con là Manager.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class Employee { protected String name; protected int salary; public Employee(String name, int salary) { this.name = name; this.salary = salary; } protected void printInfo() { System.out.println(\u0026#34;Name: \u0026#34; + this.name); System.out.println(\u0026#34;Salary: \u0026#34; + this.salary); } } public class Manager extends Employee { private int bonus; public Manager(String name, int salary, int bonus) { super(name, salary); this.bonus = bonus; } public void printInfo() { super.printInfo(); System.out.println(\u0026#34;Bonus: \u0026#34; + this.bonus); } } Trong ví dụ này, chúng ta có một lớp Employee với hai thuộc tính là name và salary, cùng với một phương thức in thông tin là printInfo(). Lớp con Manager kế thừa từ lớp cha Employee và sử dụng các thuộc tính và phương thức protected của nó.\nChúng ta có thể thấy rằng trong lớp con Manager, chúng ta không cần phải khai báo lại các thuộc tính và phương thức đã có sẵn trong lớp cha. Thay vào đó, chúng ta chỉ cần gọi các phương thức và thuộc tính đó thông qua từ khóa super.\n1 2 3 4 public void printInfo() { super.printInfo(); System.out.println(\u0026#34;Bonus: \u0026#34; + this.bonus); } Các lỗi thường gặp khi sử dụng protected trong Java # Khi sử dụng tính năng protected trong Java, chúng ta cần lưu ý một số lỗi thường gặp sau:\nLỗi truy cập: Khi chúng ta cố gắng truy cập các thành phần protected từ bên ngoài lớp cha hoặc lớp con không hợp lệ, chúng ta sẽ nhận được lỗi truy cập. Lỗi kế thừa: Khi chúng ta cố gắng kế thừa từ một lớp có các thành phần private hoặc default, chúng ta sẽ nhận được lỗi kế thừa. Lỗi định nghĩa: Khi chúng ta cố gắng định nghĩa một thành phần protected với cùng tên nhưng kiểu dữ liệu khác với một thành phần đã có trong lớp cha, chúng ta sẽ nhận được lỗi định nghĩa. Cách truy cập các thành phần protected trong Java # Để truy cập các thành phần protected của một lớp, chúng ta có thể sử dụng các phương thức và thuộc tính đó thông qua từ khóa super trong lớp con. Ngoài ra, chúng ta cũng có thể sử dụng các getter và setter để truy cập và thay đổi giá trị của các thuộc tính protected.\nVí dụ:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Rectangle extends Shape { private String color; public Rectangle(int width, int height, String color) { super(width, height); this.color = color; } public void printArea() { System.out.println(\u0026#34;Area of rectangle is: \u0026#34; + calculateArea()); } public void setColor(String color) { this.color = color; } public String getColor() { return this.color; } } Trong ví dụ này, chúng ta đã tạo ra các getter và setter cho thuộc tính color của lớp Rectangle, cho phép chúng ta truy cập và thay đổi giá trị của thuộc tính này từ bên ngoài lớp.\nTài liệu tham khảo # Các tính năng của từ khóa protected trong Java ","date":"23 June 2024","permalink":"/posts/java/javablog/blog5/","section":"Danh mục post","summary":"Tìm hiểu về tính năng protected trong Java # Tính năng protected trong Java cho phép các thành phần của một lớp được truy cập bởi các lớp con của nó.","title":"Các tính năng của từ khóa protected trong Java"},{"content":"","date":"23 June 2024","permalink":"/tags/java/","section":"Tags","summary":"","title":"Java"},{"content":"","date":"23 June 2024","permalink":"/series/java/","section":"Series","summary":"","title":"Java"},{"content":"","date":"23 June 2024","permalink":"/categories/java/","section":"Categories","summary":"","title":"Java"},{"content":"","date":"23 June 2024","permalink":"/posts/java/","section":"Danh mục post","summary":"","title":"Java"},{"content":" Java là gì? # Java là một trong những ngôn ngữ lập trình hướng đối tượng. Ngôn ngữ Java được sử dụng phổ biến trong phát triển phần mềm, trang web, game hay ứng dụng trên các thiết bị di động.\nJava được khởi đầu bởi James Gosling và bạn đồng nghiệp ở Sun MicroSystem năm 1991. Ban đầu Java được tạo ra nhằm mục đích viết phần mềm cho các sản phẩm gia dụng, và có tên là Oak. Java được chính thức phát hành năm 1994, đến năm 2010 được Oracle mua lại từ Sun MicroSystem.\nĐặc điểm của ngôn ngữ lập trình Java là gì? # Tương tự C++, hướng đối tượng hoàn toàn # Trong quá trình tạo ra một ngôn ngữ mới phục vụ cho mục đích chạy được trên nhiều nền tảng, các kỹ sư của Sun MicroSystem muốn tạo ra một ngôn ngữ dễ học và quen thuộc với đa số người lập trình. Vì vậy họ đã sử dụng lại các cú pháp của C và C++.\nTuy nhiên, trong Java thao tác với con trỏ bị lược bỏ nhằm đảo bảo tính an toàn và dễ sử dụng hơn. Các thao tác overload, goto hay các cấu trúc như struct và union cũng được loại bỏ khỏi Java.\nĐộc lập phần cứng và hệ điều hành # Một chương trình viết bằng ngôn ngữ Java có thể chạy tốt ở nhiều môi trường khác nhau. Gọi là khả năng “cross-platform”. Khả năng độc lập phần cứng và hệ điều hành được thể hiện ở 2 cấp độ là cấp độ mã nguồn và cấp độ nhị phân.\nỞ cấp độ mã nguồn: Kiểu dữ liệu trong Java nhất quán cho tất cả các hệ điều hành và phần cứng khác nhau. Java có riêng một bộ thư viện để hỗ trợ vấn đề này. Chương trình viết bằng ngôn ngữ Java có thể biên dịch trên nhiều loại máy khác nhau mà không gặp lỗi.\nỞ cấp độ nhị phân: Một mã biên dịch có thể chạy trên nhiều nền tảng khác nhau mà không cần dịch lại mã nguồn. Tuy nhiên cần có Java Virtual Machine để thông dịch đoạn mã này.\nNgôn ngữ thông dịch # Ngôn ngữ lập trình thường được chia ra làm 2 loại (tùy theo các hiện thực hóa ngôn ngữ đó) là ngôn ngữ thông dịch và ngôn ngữ biên dịch.\nThông dịch (Interpreter) : Nó dịch từng lệnh rồi chạy từng lệnh, lần sau muốn chạy lại thì phải dịch lại. Biên dịch (Compiler): Code sau khi được biên dịch sẽ tạo ra 1 file thường là .exe, và file .exe này có thể đem sử dụng lại không cần biên dịch nữa. Ngôn ngữ lập trình Java thuộc loại ngôn ngữ thông dịch. Chính xác hơn, Java là loại ngôn ngữ vừa biên dịch vừa thông dịch. Cụ thể như sau\nKhi viết mã, hệ thống tạo ra một tệp .java. Khi biên dịch mã nguồn của chương trình sẽ được biên dịch ra mã byte code. Máy ảo Java (Java Virtual Machine) sẽ thông dịch mã byte code này thành machine code (hay native code) khi nhận được yêu cầu chạy chương trình.\nƯu điểm : Phương pháp này giúp các đoạn mã viết bằng Java có thể chạy được trên nhiều nền tảng khác nhau. Với điều kiện là JVM có hỗ trợ chạy trên nền tảng này.\nNhược điểm : Cũng như các ngôn ngữ thông dịch khác, quá trình chạy các đoạn mã Java là chậm hơn các ngôn ngữ biên dịch khác (tuy nhiên vẫn ở trong một mức chấp nhận được).\nCơ chế thu gom rác tự động # Khi tạo ra các đối tượng trong Java, JRE sẽ tự động cấp phát không gian bộ nhớ cho các đối tượng ở trên heap.\nVới ngôn ngữ như C/C++, bạn sẽ phải yêu cầu hủy vùng nhớ mà bạn đã cấp phát, để tránh việc thất thoát vùng nhớ. Tuy nhiên vì một lý do nào đó, bạn không hủy một vài vùng nhớ, dẫn đến việc thất thoát và làm giảm hiệu năng chương trình.\nNgôn ngữ lập trình Java hỗ trợ cho bạn điều đó, nghĩa là bạn không phải tự gọi hủy các vùng nhớ. Bộ thu dọn rác của Java sẽ theo vết các tài nguyên đã được cấp. Khi không có tham chiếu nào đến vùng nhớ, bộ thu dọn rác sẽ tiến hành thu hồi vùng nhớ đã được cấp phát.\nĐa luồng # Java hỗ trợ lập trình đa tiến trình (multithread) để thực thi các công việc đồng thời. Đồng thời cũng cung cấp giải pháp đồng bộ giữa các tiến trình (giải pháp sử dụng priority…).\nTính an toàn và bảo mật # Tính an toàn # Ngôn ngữ lập trình Java yêu cầu chặt chẽ về kiểu dữ liệu. Dữ liệu phải được khai báo tường minh. Không sử dụng con trỏ và các phép toán với con trỏ. Java kiểm soát chặt chẽ việc truy nhập đến mảng, chuỗi. Không cho phép sử dụng các kỹ thuật tràn. Do đó các truy nhập sẽ không vượt quá kích thước của mảng hoặc chuỗi. Quá trình cấp phát và giải phóng bộ nhớ được thực hiện tự động. Cơ chế xử lý lỗi giúp việc xử lý và phục hồi lỗi dễ dàng hơn. Tính bảo mật # Java cung cấp một môi trường quản lý chương trình với nhiều mức khác nhau.\nMức 1 : Chỉ có thể truy xuất dữ liệu cũng như phương phức thông qua giao diện mà lớp cung cấp. Mức 2 : Trình biên dịch kiểm soát các đoạn mã sao cho tuân thủ các quy tắc của ngôn ngữ lập trình Java trước khi thông dịch. Mức 3 : Trình thông dịch sẽ kiểm tra mã byte code xem các đoạn mã này có đảm bảo được các quy định, quy tắc trước khi thực thi. Mức 4: Java kiểm soát việc nạp các lớp vào bộ nhớ để giám sát việc vi phạm giới hạn truy xuất trước khi nạp vào hệ thống. Các loại ứng dụng được phát triển sử dụng Java # Java là một ngôn ngữ lập trình phổ biến, mạnh mẽ và được sử dụng rộng rãi trong nhiều lĩnh vực khác nhau nhờ vào tính độc lập nền tảng, hiệu suất ổn định và bộ thư viện phong phú. Dưới đây là các ứng dụng chính của Java trong nhiều lĩnh vực:\nPhát triển Game # Java được sử dụng để phát triển nhiều game đơn giản cho cả máy tính và di động. Nhờ vào các thư viện như LibGDX và LWJGL (Lightweight Java Game Library), Java cung cấp môi trường phát triển mạnh mẽ cho các trò chơi 2D và 3D.\nĐám mây (Cloud Computing) # Java là ngôn ngữ chính được sử dụng trong các dịch vụ và hệ thống đám mây (cloud computing) do khả năng xử lý song song mạnh mẽ và bảo mật cao. Các hệ thống như Amazon Web Services (AWS), Google Cloud và Microsoft Azure đều hỗ trợ Java cho việc phát triển và triển khai các ứng dụng trên đám mây.\nDữ liệu lớn (Big Data) # Trong lĩnh vực dữ liệu lớn (Big Data), Java đóng vai trò quan trọng nhờ vào các công cụ và framework mạnh mẽ như Apache Hadoop, Apache Spark. Những framework này chủ yếu được viết bằng Java và Scala, cho phép Java có thể xử lý và phân tích lượng dữ liệu lớn một cách hiệu quả.\nPhát triển Web # Java là lựa chọn hàng đầu trong phát triển ứng dụng web nhờ vào các framework như Spring, Hibernate, và Struts. Java giúp xây dựng các ứng dụng web mạnh mẽ, bảo mật và có khả năng mở rộng tốt.\nTrí tuệ nhân tạo (Artificial Intelligence – AI) # Java cũng được sử dụng trong trí tuệ nhân tạo (AI) nhờ vào tính năng đa luồng và khả năng mở rộng. Các thư viện Java hỗ trợ các mô hình học máy, xử lý ngôn ngữ tự nhiên và các thuật toán AI như Deeplearning4j, Weka, và Apache Mahout.\nInternet of Things (IoT) # Java là một ngôn ngữ phổ biến trong Internet of Things (IoT) nhờ vào khả năng tương thích với các thiết bị nhúng và hệ thống nhúng nhỏ gọn. Các hệ thống IoT yêu cầu tính bảo mật, độ ổn định, và khả năng hoạt động trên nhiều nền tảng, điều mà Java có thể đáp ứng tốt.\nỨng dụng Doanh nghiệp # Java từ lâu đã là lựa chọn hàng đầu trong việc xây dựng các hệ thống quản lý doanh nghiệp như ERP, CRM, và các hệ thống quản lý quy trình kinh doanh phức tạp. Với Java Enterprise Edition (Java EE), các doanh nghiệp có thể phát triển các ứng dụng lớn, phức tạp và bảo mật.\nTài liệu tham khảo # Java là gì? Tổng quan về ngôn ngữ lập trình Java ","date":"23 June 2024","permalink":"/posts/java/javablog/blog1/","section":"Danh mục post","summary":"Java là gì?","title":"Java là gì? Tổng quan về ngôn ngữ lập trình Java"},{"content":" Quá tải (overloading) trong Java là gì? # Quá tải (overloading) là khả năng định nghĩa nhiều phương thức có cùng tên nhưng khác nhau về tham số trong cùng một lớp hoặc lớp con. Khi gọi đến một phương thức quá tải, trình biên dịch sẽ tự động chọn phương thức phù hợp dựa trên các tham số thực tế được cung cấp. Điều này giúp cho chương trình trở nên linh hoạt hơn, có thể thực hiện một hành động cụ thể theo nhiều cách khác nhau bằng cách thay đổi các tham số.\nOverloading là một tính năng quan trọng trong lập trình hướng đối tượng, giúp cho chương trình trở nên dễ đọc và dễ hiểu hơn. Nó cũng giúp tăng tính tái sử dụng mã và tối ưu hóa hiệu suất của chương trình.\nCác loại quá tải khác nhau trong Java # Java hỗ trợ hai loại quá tải chính: quá tải theo kiểu dữ liệu của tham số và quá tải theo số lượng tham số.\nQuá tải theo kiểu dữ liệu của tham số # Các phương thức có cùng tên nhưng khác nhau về kiểu dữ liệu của tham số được gọi là quá tải theo kiểu dữ liệu của tham số. Ví dụ:\n1 2 3 4 5 6 7 8 9 public class Calculator { public int add(int num1, int num2) { return num1 + num2; } public double add(double num1, double num2) { return num1 + num2; } } Trong ví dụ trên, chúng ta có hai phương thức add có cùng tên nhưng khác nhau về kiểu dữ liệu của tham số. Phương thức đầu tiên sử dụng hai tham số kiểu int và trả về một giá trị kiểu int, trong khi phương thức thứ hai sử dụng hai tham số kiểu double và trả về một giá trị kiểu double.\nKhi gọi đến phương thức add, trình biên dịch sẽ tự động chọn phương thức phù hợp dựa trên kiểu dữ liệu của các tham số được cung cấp.\nOverloading theo số lượng tham số # Các phương thức có cùng tên nhưng khác nhau về số lượng tham số được gọi là quá tải theo số lượng tham số. Ví dụ:\n1 2 3 4 5 6 7 8 9 public class Calculator { public int add(int num1, int num2) { return num1 + num2; } public int add(int num1, int num2, int num3) { return num1 + num2 + num3; } } Trong ví dụ trên, chúng ta có hai phương thức add có cùng tên nhưng khác nhau về số lượng tham số. Phương thức đầu tiên sử dụng hai tham số và trả về một giá trị kiểu int, trong khi phương thức thứ hai sử dụng ba tham số và trả về một giá trị kiểu int.\nKhi gọi đến phương thức add, trình biên dịch sẽ tự động chọn phương thức phù hợp dựa trên số lượng tham số được cung cấp.\nLợi ích của quá tải trong Java # Tính linh hoạt # Với quá tải, chúng ta có thể thực hiện một hành động cụ thể theo nhiều cách khác nhau bằng cách thay đổi các tham số. Ví dụ, bạn có thể có nhiều phương thức add để thực hiện phép cộng với các kiểu dữ liệu khác nhau như int, double, float,… giúp cho chương trình trở nên linh hoạt và có thể xử lý được nhiều trường hợp khác nhau.\nKhả năng đọc code # Sử dụng quá tải giúp cho code trở nên dễ hiểu hơn bằng cách sử dụng các phương thức có tên giống nhau nhưng được định nghĩa cho các ngữ cảnh khác nhau. Điều này giúp cho việc đọc và hiểu code trở nên dễ dàng hơn, đặc biệt là khi chương trình có nhiều phương thức cùng tên.\nTính tái sử dụng # Quá tải cho phép tái sử dụng mã cho các trường hợp khác nhau. Thay vì phải viết nhiều phương thức có chức năng tương tự nhau nhưng khác nhau về tham số, chúng ta có thể sử dụng quá tải để tái sử dụng mã và giảm thiểu việc lặp lại code.\nTính an toàn # Ngôn ngữ lập trình Java yêu cầu chặt chẽ về kiểu dữ liệu. Dữ liệu phải được khai báo tường minh. Không sử dụng con trỏ và các phép toán với con trỏ. Java kiểm soát chặt chẽ việc truy nhập đến mảng, chuỗi. Không cho phép sử dụng các kỹ thuật tràn. Do đó các truy nhập sẽ không vượt quá kích thước của mảng hoặc chuỗi. Quá trình cấp phát và giải phóng bộ nhớ được thực hiện tự động. Cơ chế xử lý lỗi giúp việc xử lý và phục hồi lỗi dễ dàng hơn. Tối ưu hóa hiệu suất # Với quá tải, chúng ta có thể chọn các phiên bản hiệu quả nhất của phương thức dựa trên các tham số thực tế được cung cấp. Điều này giúp cho chương trình hoạt động hiệu quả hơn và tối ưu hóa được hiệu suất của nó.\nCác quy tắc của quá tải trong Java # Để các phương thức được coi là quá tải, chúng phải tuân theo một số quy tắc sau:\nCác phương thức phải có cùng tên. Các phương thức phải được định nghĩa trong cùng một lớp hoặc lớp con. Các phương thức phải khác nhau về tham số theo một trong hai cách đã đề cập ở trên. Giá trị trả về của các phương thức có thể khác nhau. Khai báo phương thức overloading trong Java # Để khai báo một phương thức quá tải trong Java, chúng ta cần tuân theo các quy tắc đã đề cập ở trên. Ví dụ:\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class Calculator { public int add(int num1, int num2) { return num1 + num2; } public double add(double num1, double num2) { return num1 + num2; } public int add(int num1, int num2, int num3) { return num1 + num2 + num3; } } Trong ví dụ trên, chúng ta có ba phương thức add được định nghĩa trong cùng một lớp Calculator, khác nhau về số lượng và kiểu dữ liệu của tham số. Điều này cho phép chúng ta có thể gọi các phương thức này với các tham số khác nhau để thực hiện phép cộng.\nVí dụ về quá tải trong Java # Để hiểu rõ hơn về quá tải trong Java, chúng ta sẽ xem xét một ví dụ đơn giản về việc tính tổng của hai số nguyên và hai số thực.\n1 2 3 4 5 6 7 8 9 public class Calculator { public int add(int num1, int num2) { return num1 + num2; } public double add(double num1, double num2) { return num1 + num2; } } Trong ví dụ trên, chúng ta có hai phương thức add được định nghĩa trong lớp Calculator. Phương thức đầu tiên sử dụng hai tham số kiểu int và trả về một giá trị kiểu int, trong khi phương thức thứ hai sử dụng hai tham số kiểu double và trả về một giá trị kiểu double.\nBây giờ, chúng ta có thể gọi các phương thức này với các tham số khác nhau để tính tổng của hai số nguyên và hai số thực.\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class Main { public static void main(String[] args) { Calculator calculator = new Calculator(); // Tính tổng của hai số nguyên int sumInt = calculator.add(5, 10); System.out.println(\u0026#34;Tổng của hai số nguyên là: \u0026#34; + sumInt); // Tính tổng của hai số thực double sumDouble = calculator.add(3.14, 2.71); System.out.println(\u0026#34;Tổng của hai số thực là: \u0026#34; + sumDouble); } } Kết quả khi chạy chương trình:\nTổng của hai số nguyên là: 15 Tổng của hai số thực là: 5.85\nNhư vậy, chúng ta đã sử dụng quá tải để tính tổng của hai số nguyên và hai số thực bằng cách sử dụng các phương thức có cùng tên nhưng khác nhau về kiểu dữ liệu của tham số.\nPhân biệt overloading và override trong Java # Một khái niệm khác liên quan đến quá tải là ghi đè (override). Tuy nhiên, hai khái niệm này có một số điểm khác biệt nhau:\nQuá tải xảy ra khi chúng ta định nghĩa nhiều phương thức có cùng tên nhưng khác nhau về tham số trong cùng một lớp hoặc lớp con. Ghi đè xảy ra khi chúng ta định nghĩa lại một phương thức đã được định nghĩa trong lớp cha trong lớp con. Quá tải giúp cho chúng ta có thể thực hiện một hành động cụ thể theo nhiều cách khác nhau bằng cách thay đổi tham số của phương thức. Ghi đè giúp cho chúng ta có thể cải thiện hoặc mở rộng chức năng của một phương thức đã được định nghĩa trong lớp cha. Khi nào nên sử dụng quá tải trong Java? # Chúng ta nên sử dụng quá tải trong các trường hợp sau:\nCác phương thức có cùng chức năng nhưng khác nhau về tham số. Các phương thức có cùng chức năng nhưng khác nhau về kiểu dữ liệu của tham số. Các phương thức có cùng chức năng nhưng khác nhau về số lượng tham số. Với việc sử dụng quá tải, chúng ta có thể tái sử dụng mã và giảm thiểu việc lặp lại code, đồng thời cũng có thể tối ưu hóa hiệu suất của chương trình. Những mẹo hay khi sử dụng quá tải trong Java # Tránh sử dụng quá tải quá nhiều, điều này có thể làm cho mã của chúng ta trở nên khó hiểu và khó bảo trì. Nếu có thể, hãy sử dụng các kiểu dữ liệu nguyên thủy như int hoặc double thay vì các kiểu dữ liệu đối tượng để giảm thiểu việc sử dụng quá tải. Khi sử dụng quá tải, hãy đặt tên cho các phương thức sao cho dễ hiểu và thể hiện được chức năng của chúng. Hãy chắc chắn rằng các phương thức quá tải của chúng ta có cùng chức năng và chỉ khác nhau về tham số, không nên sử dụng quá tải để thực hiện các chức năng khác nhau. Tài liệu tham khảo # Khai báo phương thức overloading trong Java ","date":"23 June 2024","permalink":"/posts/java/javablog/blog2/","section":"Danh mục post","summary":"Quá tải (overloading) trong Java là gì?","title":"Khai báo phương thức overloading trong Java"},{"content":" Tính đóng gói trong Java: Sử dụng sao cho hiệu quả? # Tính đóng gói (encapsulation) là một trong những đặc điểm cơ bản và quan trọng nhất của ngôn ngữ lập trình hướng đối tượng java. Nó cho phép bạn đóng gói các trường dữ liệu và phương thức của lớp lại với nhau thành một đơn vị duy nhất, đồng thời kiểm soát quyền truy cập vào chúng, tạo ra một lớp an toàn và có thể tái sử dụng.\nTrong bài viết này, chúng ta sẽ tìm hiểu về tính năng đóng gói trong lập trình Java, cách sử dụng, lợi ích và các ví dụ cụ thể. Chúng ta cũng sẽ xem xét các quy tắc và nguyên tắc của tính đóng gói, cách bảo vệ tính đóng gói và các lỗi thường gặp khi sử dụng tính đóng gói trong Java. Cuối cùng, chúng ta sẽ phân biệt giữa tính đóng gói và tính trừu tượng, cũng như tính đóng gói và tính kế thừa trong Java.\nTính năng đóng gói trong Java # Điều này có nghĩa là các thành phần nội bộ của lớp sẽ không thể được truy cập từ bên ngoài lớp, trừ khi thông qua các phương thức công khai (public methods).\nTính đóng gói giúp tạo ra một lớp an toàn và có thể tái sử dụng. Nó ngăn chặn việc truy cập trực tiếp vào các trường dữ liệu của lớp, đảm bảo rằng chúng chỉ có thể được truy cập thông qua các phương thức công khai. Điều này giúp giảm thiểu rủi ro xảy ra lỗi và đảm bảo tính nhất quán của dữ liệu.\nCách sử dụng tính năng đóng gói trong Java # Tính đóng gói có thể được thực hiện thông qua các từ khóa phạm vi truy cập trong Java: private, protected, public và default (package-private). Chúng ta sẽ đi vào chi tiết về mỗi loại phạm vi truy cập và cách sử dụng chúng trong ví dụ dưới đây.\nTuy nhiên, chúng ta có thể truy cập vào các giá trị của hai trường này thông qua hai phương thức công khai là getName() và getAge(). Điều này cho phép chúng ta kiểm soát quyền truy cập vào các trường dữ liệu của lớp Person và đảm bảo tính nhất quán của dữ liệu.\nTừ khóa private # Từ khóa private giới hạn quyền truy cập chỉ trong lớp hiện tại. Điều này có nghĩa là các thành phần được khai báo với từ khóa private chỉ có thể được truy cập từ bên trong lớp đó. Chúng không thể được truy cập từ bên ngoài lớp, kể cả các lớp con của nó.\nTừ khóa protected # Từ khóa protected giới hạn quyền truy cập chỉ trong lớp hiện tại, các lớp con và các gói con. Điều này có nghĩa là các thành phần được khai báo với từ khóa protected có thể được truy cập từ bên trong lớp đó, các lớp con của nó và các lớp trong cùng gói.\nTừ khóa public # Từ khóa public cho phép quyền truy cập từ bất kỳ lớp nào. Điều này có nghĩa là các thành phần được khai báo với từ khóa public có thể được truy cập từ bất kỳ lớp nào, bao gồm cả các lớp ở các gói khác.\nTừ khóa default (package-private) # Từ khóa default (hay còn gọi là package-private) cho phép quyền truy cập từ các lớp trong cùng gói. Điều này có nghĩa là các thành phần được khai báo với từ khóa default chỉ có thể được truy cập từ các lớp trong cùng gói, và không thể được truy cập từ bên ngoài gói.\nLợi ích của tính năng đóng gói trong Java # Tính đóng gói mang lại nhiều lợi ích đáng kể, bao gồm:\nTăng cường tính bảo mật: Bằng cách hạn chế quyền truy cập vào các thành phần nội bộ của lớp, tính đóng gói bảo vệ dữ liệu quan trọng khỏi bị truy cập trái phép. Tăng tính nhất quán của dữ liệu: Tính đóng gói giúp đảm bảo rằng các trường dữ liệu chỉ có thể được truy cập thông qua các phương thức công khai, giúp giảm thiểu rủi ro xảy ra lỗi và đảm bảo tính nhất quán của dữ liệu. Tạo ra một lớp an toàn và có thể tái sử dụng: Tính đóng gói giúp tạo ra một lớp an toàn và có thể tái sử dụng, giúp giảm thiểu việc xảy ra lỗi và tăng tính linh hoạt của mã nguồn. Giúp kiểm soát quyền truy cập: Tính đóng gói cho phép kiểm soát quyền truy cập vào các thành phần của lớp, giúp đảm bảo tính nhất quán và an toàn của mã nguồn. Các quy tắc và nguyên tắc của tính năng đóng gói trong Java # Khi sử dụng tính đóng gói trong Java, chúng ta cần tuân thủ một số quy tắc và nguyên tắc sau:\nĐặt các trường dữ liệu là private: Điều này giúp đảm bảo rằng các trường dữ liệu chỉ có thể được truy cập thông qua các phương thức công khai, giúp tăng tính nhất quán và bảo mật của mã nguồn. Sử dụng các phương thức công khai để truy cập và thay đổi các trường dữ liệu: Việc sử dụng các phương thức công khai giúp kiểm soát quyền truy cập vào các trường dữ liệu và đảm bảo tính nhất quán của dữ liệu. Không sử dụng từ khóa public cho các trường dữ liệu: Việc sử dụng từ khóa public cho các trường dữ liệu có thể dẫn đến việc truy cập trực tiếp vào các trường này từ bên ngoài lớp, gây ra rủi ro về tính nhất quán và bảo mật của mã nguồn. Sử dụng từ khóa final cho các trường dữ liệu không thay đổi: Việc sử dụng từ khóa final giúp đảm bảo rằng các trường dữ liệu không thể bị thay đổi, giúp tăng tính nhất quán và an toàn của mã nguồn. Cách bảo vệ tính đóng gói trong Java # Để bảo vệ tính đóng gói trong Java, chúng ta có thể tuân thủ các quy tắc và nguyên tắc đã được đề cập ở trên. Ngoài ra, chúng ta cũng có thể sử dụng các kỹ thuật sau:\nSử dụng từ khóa final cho các lớp: Việc sử dụng từ khóa final cho một lớp sẽ ngăn chặn việc kế thừa từ lớp này, giúp bảo vệ tính đóng gói của lớp. Sử dụng từ khóa final cho các phương thức: Việc sử dụng từ khóa final cho một phương thức sẽ ngăn chặn việc ghi đè phương thức này trong các lớp con, giúp bảo vệ tính đóng gói của lớp. Sử dụng từ khóa final cho các trường dữ liệu: Việc sử dụng từ khóa final cho một trường dữ liệu sẽ ngăn chặn việc thay đổi giá trị của trường này, giúp bảo vệ tính nhất quán và an toàn của mã nguồn.\nCác lỗi thường gặp khi sử dụng tính đóng gói trong Java # Một số lỗi thường gặp khi sử dụng tính đóng gói trong Java bao gồm:\nLỗi không thể truy cập vào các thành phần nội bộ của lớp: Điều này có thể xảy ra khi chúng ta cố gắng truy cập vào các trường dữ liệu hoặc phương thức được khai báo là private từ bên ngoài lớp. Lỗi không thể kế thừa từ lớp được khai báo là final: Nếu một lớp được khai báo là final, chúng ta không thể kế thừa từ lớp này. Lỗi không thể ghi đè phương thức được khai báo là final: Nếu một phương thức được khai báo là final, chúng ta không thể ghi đè phương thức này trong các lớp con. Lỗi không thể thay đổi giá trị của trường dữ liệu được khai báo là final: Nếu một trường dữ liệu được khai báo là final, chúng ta không thể thay đổi giá trị của trường này. Tài liệu tham khảo # Tính đóng gói trong Java: Sử dụng sao cho hiệu quả? ","date":"23 June 2024","permalink":"/posts/java/javablog/blog4/","section":"Danh mục post","summary":"Tính đóng gói trong Java: Sử dụng sao cho hiệu quả?","title":"Tính đóng gói trong Java: Sử dụng sao cho hiệu quả?"},{"content":"","date":"16 June 2023","permalink":"/admin/","section":"Admins","summary":"","title":"Admins"},{"content":"At MeatyBytes.io, we greatly appreciate and encourage the participation of our community. We believe that comments can be a powerful tool for learning, collaboration, and the exchange of ideas. That\u0026rsquo;s why we have a dedicated comments section.\nComment Rules # To maintain a respectful and productive environment, we have established the following guidelines for comments:\n1. Be Respectful # All commenters must show respect for their fellow users. Any form of harassment, insult, personal attacks, trolling, or hate speech will not be tolerated.\n2. Stay On Topic # To maintain the relevance and utility of the comments section, please keep all comments related to the topic of the post. Off-topic comments may be removed.\n3. No Spam # Any spam or self-promotion is not allowed. This includes, but is not limited to, advertising, promotion of irrelevant products or websites, and excessive linking or referral codes.\n4. Profanity and Obscene Content # Any comments containing profanity, explicit, or obscene content will be removed. This includes inappropriate usernames.\n5. Privacy and Personal Information # Do not share or ask for personal information in the comments section. This includes, but is not limited to, full names, addresses, phone numbers, and email addresses.\n6. Intellectual Property # Respect intellectual property rights. Do not post copyrighted material without the proper attribution and/or without the explicit permission of the copyright holder.\nTerms # By using the comments section on MeatyBytes.io, you agree to follow these rules. Violation of these rules may lead to removal of your comment or, in severe cases, permanent banning from the comments section.\nPlease remember that all comments represent the thoughts and opinions of their respective authors, and not those of MeatyBytes.io or its owner. MeatyBytes and its owner is also not responsible for validating every comment, and will not be liable for any damages, real or otherwise, sustained from comments on this site.\nWe reserve the right to moderate, delete, or hide comments that we deem to violate these rules, and to modify this policy as necessary.\nIf you have any questions or concerns about this comment policy, please leave a comment or find me on social media for a PM.\nLet\u0026rsquo;s keep the MeatyBytes.io comments section a valuable resource for everyone, and the drama or spam on LinkedIn!\n","date":"16 June 2023","permalink":"/admin/comment-policy/","section":"Admins","summary":"At MeatyBytes.","title":"Comment Policy"},{"content":" General Disclosure # MeatyBytes.io is a blog owned and operated by Meaty Media. All content, including text, images, and videos, is created and published by Meaty Media, unless otherwise noted and cited. Some content may be copyright or trademarked by others, and in such cases, Meaty Media does not claim ownership or responsibility for such content. A best effort will be made to cite the source of any trademarked or otherwise owned asset, but the lack of such citation does not indicate intentional infringement. If any such asset is found on this site, please contact our administrators to either add the citation or remove the content, and it will be done so accordingly.\nMidjourney # All thumbnails were created by me using Midjourney. The images are now in the public domain, but their usage with the given content and the prompts used to generate them are of my own creation and are claimed as such.\nAffiliate Disclosures # Amazon # As an Amazon Associate I earn from qualifying purchases.\nTerms and Conditions # By accessing and using MeatyBytes, you agree to the following terms and conditions:\nAll content on MeatyBytes.io is protected by copyright and may not be reproduced, distributed, or used in any way without the express written permission of Meaty Media. MeatyBytes and its content are provided on an \u0026ldquo;as is\u0026rdquo; and \u0026ldquo;as available\u0026rdquo; basis. Meaty Media disclaims all warranties of any kind, whether express or implied, including but not limited to the implied warranties of merchantability, fitness for a particular purpose, and non-infringement. MeatyMedia does not warrant that the content on MeatyBytes is accurate, complete, or up-to-date. MeatyMedia does not claim ownership or responsibility for any content that is not created and published by Meaty Media. In the event that MeatyBytes includes content that is copyright or trademarked by others, MeatyMedia will make a best effort to cite such content and provide credit to the original creator or owner. You agree to use MeatyBytes and its content only for personal, non-commercial purposes. You may not use MeatyBytes or its content for any purpose that is unlawful or prohibited by these terms and conditions. You agree to indemnify and hold harmless Meaty Media, its officers, directors, employees, agents, and affiliates from any claim or demand, including reasonable attorneys\u0026rsquo; fees, made by any third party due to or arising out of your use of MeatyBytes or its content. MeatyMedia reserves the right to modify these terms and conditions at any time without notice. Your continued use of MeatyBytes after the effective date of any changes to these terms and conditions will constitute your acceptance of such changes. By using MeatyBytes, you acknowledge that you have read, understood, and agree to be bound by these terms and conditions. If you do not agree to these terms and conditions, please do not use MeatyBytes.\nNote: All artwork on MeatyBytes is created and owned by Meaty Media and its proprietor, Nick Miethe, unless otherwise noted and cited.\n","date":"1 January 2023","permalink":"/admin/disclosures/","section":"Admins","summary":"General Disclosure # MeatyBytes.","title":"Site Disclosures"},{"content":"","date":"1 January 0001","permalink":"","section":"","summary":"","title":""},{"content":" ","date":"1 January 0001","permalink":"/profile/","section":"Welcome to Totgo Blog!","summary":" ","title":"Profile"},{"content":"","date":"1 January 0001","permalink":"/topics/","section":"Topics","summary":"","title":"Topics"},{"content":" About Me # Chien Shiung Wu is a professor of artificial intelligence at the Stanford AI Lab. Her research interests include distributed robotics, mobile computing and programmable matter. She leads the Robotic Neurobiology group, which develops self-reconfiguring robots, systems of self-organizing robots, and mobile sensor networks.\n","date":"1 January 0001","permalink":"","section":"","summary":"About Me # Chien Shiung Wu is a professor of artificial intelligence at the Stanford AI Lab.","title":"吳健雄"}]